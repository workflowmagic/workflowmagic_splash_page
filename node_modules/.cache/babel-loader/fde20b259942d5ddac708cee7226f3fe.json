{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nvar easing_1 = require(\"@popmotion/easing\");\n\nvar morphTransition_1 = require(\"./morphTransition\");\n\nvar util_1 = require(\"./util\");\n\nvar globalAny = global;\nvar defaultsOptions = {\n  keepFrom: false,\n  type: 'morph',\n  getMargins: false,\n  portalElement: globalAny.document && globalAny.document.body,\n  spring: {\n    damping: 26,\n    mass: 1,\n    stiffness: 180\n  },\n  easings: easing_1.linear,\n  isReversed: false,\n  withMethods: false\n};\n\nfunction useMorph(opts) {\n  if (opts === void 0) {\n    opts = defaultsOptions;\n  }\n\n  var options = __assign({}, defaultsOptions, opts);\n\n  var getMargins = options.getMargins,\n      keepFrom = options.keepFrom,\n      _a = options.spring,\n      damping = _a.damping,\n      mass = _a.mass,\n      stiffness = _a.stiffness,\n      isReversed = options.isReversed;\n  var backAnimationRef = react_1.useRef();\n  var prevToRef = react_1.useRef();\n  var prevToRectRef = react_1.useRef();\n  var prevSpringRef = react_1.useRef();\n  var cleanupFromRef = react_1.useRef();\n  var setProgressRef = react_1.useRef();\n  var isAnimating = false;\n  var cleanup;\n\n  function resize() {\n    if (!prevToRef.current) return;\n    prevToRectRef.current = util_1.getRect(prevToRef.current, {\n      getMargins: getMargins\n    });\n  } // Window on resize effect.\n\n\n  react_1.useEffect(function () {\n    if (!prevToRef.current) return;\n    window.addEventListener('resize', resize);\n    return function () {\n      return window.removeEventListener('resize', resize);\n    };\n  }, []);\n\n  var animate = function animate(_a) {\n    var from = _a.from,\n        to = _a.to,\n        rectFrom = _a.rectFrom,\n        rectTo = _a.rectTo,\n        willBack = _a.willBack;\n    if (!to) return;\n    to.style.visibility = 'visible';\n    if (!from) return;\n    isAnimating = true;\n    var prevSpring = prevSpringRef.current;\n\n    switch (options.type) {\n      case 'fade':\n      case 'morph':\n      default:\n        var morph = morphTransition_1.default({\n          from: from,\n          to: to,\n          rectFrom: rectFrom,\n          rectTo: rectTo,\n          fromValue: prevSpring !== undefined && prevSpring.currentValue !== 1 ? 1 - prevSpring.currentValue : 0,\n          initialVelocity: prevSpring !== undefined && prevSpring.currentVelocity !== 0 ? prevSpring.currentVelocity * -1 : 0,\n          onUpdate: function onUpdate(s) {\n            prevSpringRef.current = s;\n          },\n          willBack: willBack,\n          options: options\n        });\n        cleanup = morph.cleanup;\n        setProgressRef.current = morph.setProgress;\n        cleanupFromRef.current = cleanup;\n    }\n\n    return function () {\n      if (isAnimating) cleanup();\n    };\n  };\n\n  react_1.useEffect(function () {\n    if (!setProgressRef.current) return;\n    setProgressRef.current(options.progress);\n  }, [options.progress]);\n  var getRef = react_1.useCallback(function (to) {\n    var from = prevToRef.current;\n    var cleanupFrom = cleanupFromRef.current;\n    if (from === to) return;\n    var willUnmount = !to;\n    var willAnimate = !!to && !!from;\n    var willBack = keepFrom && willAnimate;\n    var isBackwards = keepFrom && willUnmount && !!from;\n    if (cleanupFrom) cleanupFrom();\n\n    if (isBackwards) {\n      animate(backAnimationRef.current);\n      return;\n    }\n\n    if (willUnmount) {\n      if (cleanup) cleanup();\n      return;\n    }\n\n    var rectFrom = prevToRectRef.current;\n    var rectTo = util_1.getRect(to, {\n      getMargins: getMargins\n    });\n    animate({\n      from: from,\n      rectFrom: rectFrom,\n      to: to,\n      rectTo: rectTo,\n      willBack: willBack\n    });\n    backAnimationRef.current = {\n      from: to,\n      rectFrom: rectTo,\n      to: from,\n      rectTo: rectFrom\n    };\n\n    if (!willBack) {\n      prevToRef.current = to;\n      prevToRectRef.current = rectTo;\n    }\n  }, [keepFrom, damping, mass, stiffness, isReversed]);\n  var style = {\n    visibility: 'hidden'\n  };\n  var props = {\n    ref: getRef,\n    style: style\n  };\n\n  var propsFn = function propsFn(_a) {\n    if (_a === void 0) {\n      _a = {};\n    }\n\n    var _b = _a.style,\n        style = _b === void 0 ? {} : _b,\n        extra = __rest(_a, [\"style\"]);\n\n    return __assign({}, props, {\n      style: __assign({}, props.style, style)\n    });\n  };\n\n  propsFn.ref = getRef;\n  propsFn.style = style;\n\n  if (options.withMethods) {\n    return [propsFn, {\n      resize: resize\n    }];\n  }\n\n  return propsFn;\n}\n\nexports.default = useMorph;","map":null,"metadata":{},"sourceType":"script"}