{"ast":null,"code":"import _classCallCheck from \"/home/wktdev/Desktop/workflowmagic_splash_page/workflowmagic/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/wktdev/Desktop/workflowmagic_splash_page/workflowmagic/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n *  @license\r\n *  Copyright 2017 Adam Miskiewicz\r\n *\r\n *  Use of this source code is governed by a MIT-style license that can be found\r\n *  in the LICENSE file or at https://opensource.org/licenses/MIT.\r\n */\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction withDefault(maybeValue, defaultValue) {\n  return typeof maybeValue !== \"undefined\" && maybeValue !== null ? maybeValue : defaultValue;\n}\n/**\r\n *  @license\r\n *  Copyright 2017 Adam Miskiewicz\r\n *\r\n *  Use of this source code is governed by a MIT-style license that can be found\r\n *  in the LICENSE file or at https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Implements a spring physics simulation based on the equations behind\r\n * damped harmonic oscillators (https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator).\r\n */\n\n\nvar Spring = /*#__PURE__*/function () {\n  function Spring() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Spring);\n\n    this._listeners = [];\n    this._currentAnimationStep = 0; // current requestAnimationFrame\n\n    this._currentTime = 0; // Current timestamp of animation in ms (real time)\n\n    this._springTime = 0; // Current time along the spring curve in ms (zero-based)\n\n    this._currentValue = 0; // the current value of the spring\n\n    this._currentVelocity = 0; // the current velocity of the spring\n\n    this._isAnimating = false;\n    this._oscillationVelocityPairs = [];\n    this._config = {\n      fromValue: withDefault(config.fromValue, 0),\n      toValue: withDefault(config.toValue, 1),\n      stiffness: withDefault(config.stiffness, 100),\n      damping: withDefault(config.damping, 10),\n      mass: withDefault(config.mass, 1),\n      initialVelocity: withDefault(config.initialVelocity, 0),\n      overshootClamping: withDefault(config.overshootClamping, false),\n      allowsOverdamping: withDefault(config.allowsOverdamping, false),\n      restVelocityThreshold: withDefault(config.restVelocityThreshold, 0.001),\n      restDisplacementThreshold: withDefault(config.restDisplacementThreshold, 0.001)\n    };\n    this._currentValue = this._config.fromValue;\n    this._currentVelocity = this._config.initialVelocity;\n  }\n  /**\r\n   * If `fromValue` differs from `toValue`, or `initialVelocity` is non-zero,\r\n   * start the simulation and call the `onStart` listeners.\r\n   */\n\n\n  _createClass(Spring, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var _this$_config = this._config,\n          fromValue = _this$_config.fromValue,\n          toValue = _this$_config.toValue,\n          initialVelocity = _this$_config.initialVelocity;\n\n      if (fromValue !== toValue || initialVelocity !== 0) {\n        this._reset();\n\n        this._isAnimating = true;\n\n        if (!this._currentAnimationStep) {\n          this._notifyListeners(\"onStart\");\n\n          this._currentAnimationStep = requestAnimationFrame(function (t) {\n            _this._step(Date.now());\n          });\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * If a simulation is in progress, stop it and call the `onStop` listeners.\r\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this._isAnimating) {\n        return this;\n      }\n\n      this._isAnimating = false;\n\n      this._notifyListeners(\"onStop\");\n\n      if (this._currentAnimationStep) {\n        cancelAnimationFrame(this._currentAnimationStep);\n        this._currentAnimationStep = 0;\n      }\n\n      return this;\n    }\n    /**\r\n     * The spring's current position.\r\n     */\n\n  }, {\n    key: \"updateConfig\",\n\n    /**\r\n     * Updates the spring config with the given values.  Values not explicitly\r\n     * supplied will be reused from the existing config.\r\n     */\n    value: function updateConfig(updatedConfig) {\n      // When we update the spring config, we reset the simulation to ensure the\n      // spring always moves the full distance between `fromValue` and `toValue`.\n      // To ensure that the simulation behaves correctly if those values aren't\n      // being changed in `updatedConfig`, we run the simulation with `_step()`\n      // and default `fromValue` and `initialVelocity` to their current values.\n      this._advanceSpringToTime(Date.now());\n\n      var baseConfig = {\n        fromValue: this._currentValue,\n        initialVelocity: this._currentVelocity\n      };\n      this._config = Object.assign({}, this._config, baseConfig, updatedConfig);\n\n      this._reset();\n\n      return this;\n    }\n    /**\r\n     * The provided callback will be invoked when the simulation begins.\r\n     */\n\n  }, {\n    key: \"onStart\",\n    value: function onStart(listener) {\n      this._listeners.push({\n        onStart: listener\n      });\n\n      return this;\n    }\n    /**\r\n     * The provided callback will be invoked on each frame while the simulation is\r\n     * running.\r\n     */\n\n  }, {\n    key: \"onUpdate\",\n    value: function onUpdate(listener) {\n      this._listeners.push({\n        onUpdate: listener\n      });\n\n      return this;\n    }\n    /**\r\n     * The provided callback will be invoked when the simulation ends.\r\n     */\n\n  }, {\n    key: \"onStop\",\n    value: function onStop(listener) {\n      this._listeners.push({\n        onStop: listener\n      });\n\n      return this;\n    }\n    /**\r\n     * Remove a single listener from this spring.\r\n     */\n\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(listenerFn) {\n      this._listeners = this._listeners.reduce(function (result, listener) {\n        var foundListenerFn = Object.values(listener).indexOf(listenerFn) !== -1;\n\n        if (!foundListenerFn) {\n          result.push(listener);\n        }\n\n        return result;\n      }, []);\n      return this;\n    }\n    /**\r\n     * Removes all listeners from this spring.\r\n     */\n\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this._listeners = [];\n      return this;\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._currentTime = Date.now();\n      this._springTime = 0.0;\n      this._currentValue = this._config.fromValue;\n      this._currentVelocity = this._config.initialVelocity;\n    }\n  }, {\n    key: \"_notifyListeners\",\n    value: function _notifyListeners(eventName) {\n      var _this2 = this;\n\n      this._listeners.forEach(function (listener) {\n        var maybeListenerFn = listener[eventName];\n\n        if (typeof maybeListenerFn === \"function\") {\n          maybeListenerFn(_this2);\n        }\n      });\n    }\n    /**\r\n     * `_step` is the main loop.  While the animation is running, it updates the\r\n     * current state once per frame, and schedules the next frame if the spring is\r\n     * not yet at rest.\r\n     */\n\n  }, {\n    key: \"_step\",\n    value: function _step(timestamp) {\n      var _this3 = this;\n\n      this._advanceSpringToTime(timestamp, true); // check `_isAnimating`, in case `stop()` got called during\n      // `_advanceSpringToTime()`\n\n\n      if (this._isAnimating) {\n        this._currentAnimationStep = requestAnimationFrame(function (t) {\n          return _this3._step(Date.now());\n        });\n      }\n    }\n  }, {\n    key: \"_advanceSpringToTime\",\n    value: function _advanceSpringToTime(timestamp) {\n      var shouldNotifyListeners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // `_advanceSpringToTime` updates `_currentTime` and triggers the listeners.\n      // Because of these side effects, it's only safe to call when an animation\n      // is already in-progress.\n      if (!this._isAnimating) {\n        return;\n      }\n\n      var deltaTime = timestamp - this._currentTime; // If for some reason we lost a lot of frames (e.g. process large payload or\n      // stopped in the debugger), we only advance by 4 frames worth of\n      // computation and will continue on the next frame. It's better to have it\n      // running at slower speed than jumping to the end.\n\n      if (deltaTime > Spring.MAX_DELTA_TIME_MS) {\n        deltaTime = Spring.MAX_DELTA_TIME_MS;\n      }\n\n      this._springTime += deltaTime;\n      var c = this._config.damping;\n      var m = this._config.mass;\n      var k = this._config.stiffness;\n      var fromValue = this._config.fromValue;\n      var toValue = this._config.toValue;\n      var v0 = -this._config.initialVelocity;\n      invariant(m > 0, \"Mass value must be greater than 0\");\n      invariant(k > 0, \"Stiffness value must be greater than 0\");\n      invariant(c > 0, \"Damping value must be greater than 0\");\n      var zeta = c / (2 * Math.sqrt(k * m)); // damping ratio (dimensionless)\n\n      var omega0 = Math.sqrt(k / m) / 1000; // undamped angular frequency of the oscillator (rad/ms)\n\n      var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay\n\n      var omega2 = omega0 * Math.sqrt(zeta * zeta - 1.0); // frequency of damped oscillation\n\n      var x0 = toValue - fromValue; // initial displacement of the spring at t = 0\n\n      if (zeta > 1 && !this._config.allowsOverdamping) {\n        zeta = 1;\n      }\n\n      var oscillation = 0.0;\n      var velocity = 0.0;\n      var t = this._springTime;\n\n      if (zeta < 1) {\n        // Under damped\n        var envelope = Math.exp(-zeta * omega0 * t);\n        oscillation = toValue - envelope * ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) + x0 * Math.cos(omega1 * t)); // This looks crazy -- it's actually just the derivative of the\n        // oscillation function\n\n        velocity = zeta * omega0 * envelope * (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 + x0 * Math.cos(omega1 * t)) - envelope * (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) - omega1 * x0 * Math.sin(omega1 * t));\n      } else if (zeta === 1) {\n        // Critically damped\n        var _envelope = Math.exp(-omega0 * t);\n\n        oscillation = toValue - _envelope * (x0 + (v0 + omega0 * x0) * t);\n        velocity = _envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));\n      } else {\n        // Overdamped\n        var _envelope2 = Math.exp(-zeta * omega0 * t);\n\n        oscillation = toValue - _envelope2 * ((v0 + zeta * omega0 * x0) * Math.sinh(omega2 * t) + omega2 * x0 * Math.cosh(omega2 * t)) / omega2;\n        velocity = _envelope2 * zeta * omega0 * (Math.sinh(omega2 * t) * (v0 + zeta * omega0 * x0) + x0 * omega2 * Math.cosh(omega2 * t)) / omega2 - _envelope2 * (omega2 * Math.cosh(omega2 * t) * (v0 + zeta * omega0 * x0) + omega2 * omega2 * x0 * Math.sinh(omega2 * t)) / omega2;\n      }\n\n      this._currentTime = timestamp;\n      this._currentValue = oscillation;\n      this._currentVelocity = velocity;\n\n      if (!shouldNotifyListeners) {\n        return;\n      }\n\n      this._notifyListeners(\"onUpdate\");\n\n      if (!this._isAnimating) {\n        // a listener might have stopped us in _onUpdate\n        return;\n      } // If the Spring is overshooting (when overshoot clamping is on), or if the\n      // spring is at rest (based on the thresholds set in the config), stop the\n      // animation.\n\n\n      if (this._isSpringOvershooting() || this._isSpringAtRest()) {\n        if (k !== 0) {\n          // Ensure that we end up with a round value\n          this._currentValue = toValue;\n          this._currentVelocity = 0;\n\n          this._notifyListeners(\"onUpdate\");\n        }\n\n        this.stop();\n        return;\n      }\n    }\n  }, {\n    key: \"_isSpringOvershooting\",\n    value: function _isSpringOvershooting() {\n      var _this$_config2 = this._config,\n          stiffness = _this$_config2.stiffness,\n          fromValue = _this$_config2.fromValue,\n          toValue = _this$_config2.toValue,\n          overshootClamping = _this$_config2.overshootClamping;\n      var isOvershooting = false;\n\n      if (overshootClamping && stiffness !== 0) {\n        if (fromValue < toValue) {\n          isOvershooting = this._currentValue > toValue;\n        } else {\n          isOvershooting = this._currentValue < toValue;\n        }\n      }\n\n      return isOvershooting;\n    }\n  }, {\n    key: \"_isSpringAtRest\",\n    value: function _isSpringAtRest() {\n      var _this$_config3 = this._config,\n          stiffness = _this$_config3.stiffness,\n          toValue = _this$_config3.toValue,\n          restDisplacementThreshold = _this$_config3.restDisplacementThreshold,\n          restVelocityThreshold = _this$_config3.restVelocityThreshold;\n      var isNoVelocity = Math.abs(this._currentVelocity) <= restVelocityThreshold;\n      var isNoDisplacement = stiffness !== 0 && Math.abs(toValue - this._currentValue) <= restDisplacementThreshold;\n      return isNoDisplacement && isNoVelocity;\n    }\n  }, {\n    key: \"currentValue\",\n    get: function get() {\n      return this._currentValue;\n    }\n    /**\r\n     * The spring's current velocity in units / ms.\r\n     */\n\n  }, {\n    key: \"currentVelocity\",\n    get: function get() {\n      return this._currentVelocity; // give velocity in units/ms;\n    }\n    /**\r\n     * If the spring has reached its `toValue`, or if its velocity is below the\r\n     * `restVelocityThreshold`, it is considered at rest. If `stop()` is called\r\n     * during a simulation, both `isAnimating` and `isAtRest` will be false.\r\n     */\n\n  }, {\n    key: \"isAtRest\",\n    get: function get() {\n      return this._isSpringAtRest();\n    }\n    /**\r\n     * Whether or not the spring is currently emitting values.\r\n     *\r\n     * Note: this is distinct from whether or not it is at rest.\r\n     * See also `isAtRest`.\r\n     */\n\n  }, {\n    key: \"isAnimating\",\n    get: function get() {\n      return this._isAnimating;\n    }\n  }]);\n\n  return Spring;\n}();\n\nSpring.MAX_DELTA_TIME_MS = 1 / 60 * 1000 * 4; // advance 4 frames at max\n\nexport { Spring };","map":null,"metadata":{},"sourceType":"module"}