{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar easings_1 = require(\"./easings\");\n\nvar px = function px(x) {\n  return x + \"px\";\n};\n\nexports.getRects = function (node) {\n  var _a = node.getBoundingClientRect(),\n      left = _a.left,\n      top = _a.top,\n      width = _a.width,\n      height = _a.height;\n\n  return {\n    left: px(left),\n    top: px(top),\n    width: px(width),\n    height: px(height)\n  };\n};\n\nexports.applyOverlayStyle = function (node, styles) {\n  if (styles === void 0) {\n    styles = {};\n  }\n\n  Object.assign(node.style, __assign({\n    position: 'absolute',\n    // border: '2px solid red',\n    'transform-origin': 'top left'\n  }, styles));\n};\n\nexports.diffRect = function (a, b) {\n  return {\n    translateY: parseInt(a.top || '0', 10) - parseInt(b.top || '0', 10),\n    translateX: parseInt(a.left || '0', 10) - parseInt(b.left || '0', 10),\n    scaleY: parseInt(a.height || '0', 10) / parseInt(b.height || '0', 10),\n    scaleX: parseInt(a.width || '0', 10) / parseInt(b.width || '0', 10)\n  };\n};\n\nexports.getTransformString = function (_a, removeScale) {\n  var translateY = _a.translateY,\n      translateX = _a.translateX,\n      scaleY = _a.scaleY,\n      scaleX = _a.scaleX;\n\n  if (removeScale === void 0) {\n    removeScale = false;\n  }\n\n  return \"\\n  translateY(\" + px(translateY) + \")\\n\\ttranslateX(\" + px(translateX) + \")\\n\\t\" + (!removeScale ? \"\\n\\t  scaleY(\" + scaleY + \")\\n\\t  scaleX(\" + scaleX + \")\\n\\t\" : '') + \"\\n\";\n};\n\nexports.getRect = function (elm, _a) {\n  var _b = (_a === void 0 ? {} : _a).getMargins,\n      getMargins = _b === void 0 ? false : _b;\n  var box = elm.getBoundingClientRect();\n  var styles = getComputedStyle(elm);\n  return {\n    top: px(box.top + window.scrollY - (getMargins ? parseInt(styles.marginTop || '0', 10) : 0)),\n    left: px(box.left + window.scrollX - (getMargins ? parseInt(styles.marginLeft || '0', 10) : 0)),\n    width: px(box.width + (getMargins ? parseInt(styles.marginLeft || '0', 10) + parseInt(styles.marginRight || '0', 10) : 0)),\n    height: px(box.height + (getMargins ? parseInt(styles.marginTop || '0', 10) + parseInt(styles.marginBottom || '0', 10) : 0))\n  };\n};\n\nexports.getValueFromProgress = function (from, to, progress) {\n  return -progress * from + progress * to + from;\n};\n\nexports.interpolateObject = function (from, to, _a) {\n  if (from === void 0) {\n    from = {};\n  }\n\n  if (to === void 0) {\n    to = {};\n  }\n\n  var _b = _a.easings,\n      easings = _b === void 0 ? easings_1.linear : _b,\n      isReversed = _a.isReversed;\n  return function (t) {\n    return __assign({}, Object.keys(from).reduce(function (acc, key) {\n      var _a;\n\n      var shouldRev = isReversed ? easings_1.createReversed : function (x) {\n        return x;\n      };\n      var easeFn = shouldRev(typeof easings === 'function' ? easings : easings[key] || easings_1.linear);\n      return __assign((_a = {}, _a[key] = exports.getValueFromProgress(from[key], to[key], easeFn(t)), _a), acc);\n    }, {}));\n  };\n};\n\nexports.cloneElement = function (element, _a) {\n  var portalElement = _a.portalElement,\n      _b = _a.zIndex,\n      zIndex = _b === void 0 ? 0 : _b;\n  var cloneContainer = document.createElement('div');\n  var clone = element.cloneNode(true);\n  cloneContainer.classList.add('rm-cloned'); // cloneContainer.style.pointerEvents = \"none\";\n\n  cloneContainer.style.zIndex = String(1 + zIndex);\n  cloneContainer.appendChild(clone);\n  portalElement.appendChild(cloneContainer);\n  return cloneContainer;\n};\n\nexports.clamp = function (min, max) {\n  return function (x) {\n    return Math.min(Math.max(x, min), max);\n  };\n};\n\nexports.clampProgress = exports.clamp(0, 1);\n\nexports.lerp = function (from, to, isClamped) {\n  return function (t) {\n    return exports.getValueFromProgress(from, to, isClamped ? exports.clampProgress(t) : t);\n  };\n};\n\nexports.default = {\n  interpolateObject: exports.interpolateObject\n};","map":null,"metadata":{},"sourceType":"script"}