{"ast":null,"code":"/* ========================================================================== \n *                           dexie-export-import.js\n * ==========================================================================\n *\n * Dexie addon for exporting and importing databases to / from Blobs.\n *\n * By David Fahlander, david.fahlander@gmail.com,\n *\n * ==========================================================================\n *\n * Version {version}, {date}\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n * \n */\nimport Dexie from 'dexie';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction getSchemaString(table) {\n  var primKeyAndIndexes = [table.schema.primKey].concat(table.schema.indexes);\n  return primKeyAndIndexes.map(function (index) {\n    return index.src;\n  }).join(',');\n}\n\nfunction extractDbSchema(exportedDb) {\n  var schema = {};\n\n  for (var _i = 0, _a = exportedDb.tables; _i < _a.length; _i++) {\n    var table = _a[_i];\n    schema[table.name] = table.schema;\n  }\n\n  return schema;\n}\n\nfunction readBlobAsync(blob, type) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n\n    reader.onabort = function (ev) {\n      return reject(new Error(\"file read aborted\"));\n    };\n\n    reader.onerror = function (ev) {\n      return reject(ev.target.error);\n    };\n\n    reader.onload = function (ev) {\n      return resolve(ev.target.result);\n    };\n\n    if (type === 'binary') reader.readAsArrayBuffer(blob);else reader.readAsText(blob);\n  });\n}\n\nfunction readBlobSync(blob, type) {\n  if (typeof FileReaderSync === 'undefined') {\n    throw new Error('FileReaderSync missing. Reading blobs synchronously requires code to run from within a web worker. Use TSON.encapsulateAsync() to do it from the main thread.');\n  }\n\n  var reader = new FileReaderSync(); // Requires worker environment\n\n  var data = type === 'binary' ? reader.readAsArrayBuffer(blob) : reader.readAsText(blob);\n  return data;\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar typeson = createCommonjsModule(function (module, exports) {\n  !function (e, n) {\n    module.exports = n();\n  }(commonjsGlobal, function () {\n    var e = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    },\n        n = function () {\n      return function (e, n) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return function sliceIterator(e, n) {\n          var t = [],\n              r = !0,\n              i = !1,\n              o = void 0;\n\n          try {\n            for (var s, c = e[Symbol.iterator](); !(r = (s = c.next()).done) && (t.push(s.value), !n || t.length !== n); r = !0) {\n              ;\n            }\n          } catch (e) {\n            i = !0, o = e;\n          } finally {\n            try {\n              !r && c.return && c.return();\n            } finally {\n              if (i) throw o;\n            }\n          }\n\n          return t;\n        }(e, n);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        t = function t(e) {\n      if (Array.isArray(e)) {\n        for (var n = 0, t = Array(e.length); n < e.length; n++) {\n          t[n] = e[n];\n        }\n\n        return t;\n      }\n\n      return Array.from(e);\n    },\n        r = Object.keys,\n        i = Array.isArray,\n        o = {}.toString,\n        s = Object.getPrototypeOf,\n        c = {}.hasOwnProperty,\n        a = c.toString,\n        u = [\"type\", \"replaced\", \"iterateIn\", \"iterateUnsetNumeric\"];\n\n    function isThenable(e, n) {\n      return Typeson.isObject(e) && \"function\" == typeof e.then && (!n || \"function\" == typeof e.catch);\n    }\n\n    function toStringTag(e) {\n      return o.call(e).slice(8, -1);\n    }\n\n    function hasConstructorOf(n, t) {\n      if (!n || \"object\" !== (void 0 === n ? \"undefined\" : e(n))) return !1;\n      var r = s(n);\n      if (!r) return !1;\n      var i = c.call(r, \"constructor\") && r.constructor;\n      return \"function\" != typeof i ? null === t : \"function\" == typeof i && null !== t && a.call(i) === a.call(t);\n    }\n\n    function isPlainObject(e) {\n      return !(!e || \"Object\" !== toStringTag(e)) && (!s(e) || hasConstructorOf(e, Object));\n    }\n\n    function isObject(n) {\n      return n && \"object\" === (void 0 === n ? \"undefined\" : e(n));\n    }\n\n    function Typeson(o) {\n      var s = [],\n          c = [],\n          a = {},\n          y = this.types = {},\n          p = this.stringify = function (e, n, t, r) {\n        r = Object.assign({}, o, r, {\n          stringification: !0\n        });\n        var s = l(e, null, r);\n        return i(s) ? JSON.stringify(s[0], n, t) : s.then(function (e) {\n          return JSON.stringify(e, n, t);\n        });\n      };\n\n      this.stringifySync = function (e, n, t, r) {\n        return p(e, n, t, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, r, {\n          sync: !0\n        }));\n      }, this.stringifyAsync = function (e, n, t, r) {\n        return p(e, n, t, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, r, {\n          sync: !1\n        }));\n      };\n\n      var f = this.parse = function (e, n, t) {\n        return t = Object.assign({}, o, t, {\n          parse: !0\n        }), h(JSON.parse(e, n), t);\n      };\n\n      this.parseSync = function (e, n, t) {\n        return f(e, n, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, t, {\n          sync: !0\n        }));\n      }, this.parseAsync = function (e, n, t) {\n        return f(e, n, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, t, {\n          sync: !1\n        }));\n      }, this.specialTypeNames = function (e, n) {\n        var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n        return t.returnTypeNames = !0, this.encapsulate(e, n, t);\n      }, this.rootTypeName = function (e, n) {\n        var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n        return t.iterateNone = !0, this.encapsulate(e, n, t);\n      };\n\n      var l = this.encapsulate = function (y, p, f) {\n        var l = (f = Object.assign({\n          sync: !0\n        }, o, f)).sync,\n            h = {},\n            v = [],\n            d = [],\n            b = [],\n            O = !(f && \"cyclic\" in f) || f.cyclic,\n            m = f.encapsulateObserver,\n            T = _encapsulate(\"\", y, O, p || {}, b);\n\n        function finish(e) {\n          var n = Object.values(h);\n          if (f.iterateNone) return n.length ? n[0] : Typeson.getJSONType(e);\n\n          if (n.length) {\n            if (f.returnTypeNames) return [].concat(t(new Set(n)));\n            e && isPlainObject(e) && !e.hasOwnProperty(\"$types\") ? e.$types = h : e = {\n              $: e,\n              $types: {\n                $: h\n              }\n            };\n          } else isObject(e) && e.hasOwnProperty(\"$types\") && (e = {\n            $: e,\n            $types: !0\n          });\n\n          return !f.returnTypeNames && e;\n        }\n\n        return b.length ? l && f.throwOnBadSyncType ? function () {\n          throw new TypeError(\"Sync method requested but async result obtained\");\n        }() : Promise.resolve(function checkPromises(e, t) {\n          return Promise.all(t.map(function (e) {\n            return e[1].p;\n          })).then(function (r) {\n            return Promise.all(r.map(function (r) {\n              var i = [],\n                  o = t.splice(0, 1)[0],\n                  s = n(o, 7),\n                  c = s[0],\n                  a = s[2],\n                  u = s[3],\n                  y = s[4],\n                  p = s[5],\n                  f = s[6],\n                  l = _encapsulate(c, r, a, u, i, !0, f),\n                  h = hasConstructorOf(l, TypesonPromise);\n\n              return c && h ? l.p.then(function (n) {\n                return y[p] = n, checkPromises(e, i);\n              }) : (c ? y[p] = l : e = h ? l.p : l, checkPromises(e, i));\n            }));\n          }).then(function () {\n            return e;\n          });\n        }(T, b)).then(finish) : !l && f.throwOnBadSyncType ? function () {\n          throw new TypeError(\"Async method requested but sync result obtained\");\n        }() : f.stringification && l ? [finish(T)] : l ? finish(T) : Promise.resolve(finish(T));\n\n        function _adaptBuiltinStateObjectProperties(e, n, t) {\n          Object.assign(e, n);\n          var r = u.map(function (n) {\n            var t = e[n];\n            return delete e[n], t;\n          });\n          t(), u.forEach(function (n, t) {\n            e[n] = r[t];\n          });\n        }\n\n        function _encapsulate(n, t, o, c, a, u, y) {\n          var p = void 0,\n              l = {},\n              b = void 0 === t ? \"undefined\" : e(t),\n              O = m ? function (e) {\n            var r = y || c.type || Typeson.getJSONType(t);\n            m(Object.assign(e || l, {\n              keypath: n,\n              value: t,\n              cyclic: o,\n              stateObj: c,\n              promisesData: a,\n              resolvingTypesonPromise: u,\n              awaitingTypesonPromise: hasConstructorOf(t, TypesonPromise)\n            }, void 0 !== r ? {\n              type: r\n            } : {}));\n          } : null;\n          if (b in {\n            string: 1,\n            boolean: 1,\n            number: 1,\n            undefined: 1\n          }) return void 0 === t || \"number\" === b && (isNaN(t) || t === -1 / 0 || t === 1 / 0) ? (p = replace(n, t, c, a, !1, u, O)) !== t && (l = {\n            replaced: p\n          }) : p = t, O && O(), p;\n          if (null === t) return O && O(), t;\n\n          if (o && !c.iterateIn && !c.iterateUnsetNumeric) {\n            var T = v.indexOf(t);\n            if (!(T < 0)) return h[n] = \"#\", O && O({\n              cyclicKeypath: d[T]\n            }), \"#\" + d[T];\n            !0 === o && (v.push(t), d.push(n));\n          }\n\n          var g = isPlainObject(t),\n              P = i(t),\n              j = (g || P) && (!s.length || c.replaced) || c.iterateIn ? t : replace(n, t, c, a, g || P, null, O),\n              S = void 0;\n          if (j !== t ? (p = j, l = {\n            replaced: j\n          }) : P || \"array\" === c.iterateIn ? (S = new Array(t.length), l = {\n            clone: S\n          }) : g || \"object\" === c.iterateIn ? l = {\n            clone: S = {}\n          } : \"\" === n && hasConstructorOf(t, TypesonPromise) ? (a.push([n, t, o, c, void 0, void 0, c.type]), p = t) : p = t, O && O(), f.iterateNone) return S || p;\n          if (!S) return p;\n\n          if (c.iterateIn) {\n            var w = function _loop(e) {\n              var r = {\n                ownKeys: t.hasOwnProperty(e)\n              };\n\n              _adaptBuiltinStateObjectProperties(c, r, function () {\n                var r = n + (n ? \".\" : \"\") + escapeKeyPathComponent(e),\n                    i = _encapsulate(r, t[e], !!o, c, a, u);\n\n                hasConstructorOf(i, TypesonPromise) ? a.push([r, i, !!o, c, S, e, c.type]) : void 0 !== i && (S[e] = i);\n              });\n            };\n\n            for (var A in t) {\n              w(A);\n            }\n\n            O && O({\n              endIterateIn: !0,\n              end: !0\n            });\n          } else r(t).forEach(function (e) {\n            var r = n + (n ? \".\" : \"\") + escapeKeyPathComponent(e);\n\n            _adaptBuiltinStateObjectProperties(c, {\n              ownKeys: !0\n            }, function () {\n              var n = _encapsulate(r, t[e], !!o, c, a, u);\n\n              hasConstructorOf(n, TypesonPromise) ? a.push([r, n, !!o, c, S, e, c.type]) : void 0 !== n && (S[e] = n);\n            });\n          }), O && O({\n            endIterateOwn: !0,\n            end: !0\n          });\n\n          if (c.iterateUnsetNumeric) {\n            for (var C = t.length, N = function _loop2(e) {\n              if (!(e in t)) {\n                var r = n + (n ? \".\" : \"\") + e;\n\n                _adaptBuiltinStateObjectProperties(c, {\n                  ownKeys: !1\n                }, function () {\n                  var n = _encapsulate(r, void 0, !!o, c, a, u);\n\n                  hasConstructorOf(n, TypesonPromise) ? a.push([r, n, !!o, c, S, e, c.type]) : void 0 !== n && (S[e] = n);\n                });\n              }\n            }, B = 0; B < C; B++) {\n              N(B);\n            }\n\n            O && O({\n              endIterateUnsetNumeric: !0,\n              end: !0\n            });\n          }\n\n          return S;\n        }\n\n        function replace(e, n, t, r, i, o, u) {\n          for (var y = i ? s : c, p = y.length; p--;) {\n            var f = y[p];\n\n            if (f.test(n, t)) {\n              var v = f.type;\n\n              if (a[v]) {\n                var d = h[e];\n                h[e] = d ? [v].concat(d) : v;\n              }\n\n              return Object.assign(t, {\n                type: v,\n                replaced: !0\n              }), !l && f.replaceAsync || f.replace ? (u && u({\n                replacing: !0\n              }), _encapsulate(e, f[l || !f.replaceAsync ? \"replace\" : \"replaceAsync\"](n, t), O && \"readonly\", t, r, o, v)) : (u && u({\n                typeDetected: !0\n              }), _encapsulate(e, n, O && \"readonly\", t, r, o, v));\n            }\n          }\n\n          return n;\n        }\n      };\n\n      this.encapsulateSync = function (e, n, t) {\n        return l(e, n, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, t, {\n          sync: !0\n        }));\n      }, this.encapsulateAsync = function (e, n, t) {\n        return l(e, n, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, t, {\n          sync: !1\n        }));\n      };\n\n      var h = this.revive = function (e, t) {\n        var s = (t = Object.assign({\n          sync: !0\n        }, o, t)).sync,\n            c = e && e.$types,\n            u = !0;\n        if (!c) return e;\n        if (!0 === c) return e.$;\n        c.$ && isPlainObject(c.$) && (e = e.$, c = c.$, u = !1);\n\n        var y = [],\n            p = {},\n            f = function _revive(e, t, o, s, f, l) {\n          if (u && \"$types\" === e) return;\n          var h = c[e];\n\n          if (i(t) || isPlainObject(t)) {\n            var v = i(t) ? new Array(t.length) : {};\n\n            for (r(t).forEach(function (n) {\n              var r = _revive(e + (e ? \".\" : \"\") + escapeKeyPathComponent(n), t[n], o || v, s, v, n);\n\n              hasConstructorOf(r, Undefined) ? v[n] = void 0 : void 0 !== r && (v[n] = r);\n            }), t = v; y.length;) {\n              var d = n(y[0], 4),\n                  b = d[0],\n                  O = d[1],\n                  m = d[2],\n                  T = d[3],\n                  g = getByKeyPath(b, O);\n              if (hasConstructorOf(g, Undefined)) m[T] = void 0;else {\n                if (void 0 === g) break;\n                m[T] = g;\n              }\n              y.splice(0, 1);\n            }\n          }\n\n          if (!h) return t;\n\n          if (\"#\" === h) {\n            var P = getByKeyPath(o, t.substr(1));\n            return void 0 === P && y.push([o, t.substr(1), f, l]), P;\n          }\n\n          var j = s.sync;\n          return [].concat(h).reduce(function (e, n) {\n            var t = a[n];\n            if (!t) throw new Error(\"Unregistered type: \" + n);\n            return t[j && t.revive ? \"revive\" : !j && t.reviveAsync ? \"reviveAsync\" : \"revive\"](e, p);\n          }, t);\n        }(\"\", e, null, t);\n\n        return isThenable(f = hasConstructorOf(f, Undefined) ? void 0 : f) ? s && t.throwOnBadSyncType ? function () {\n          throw new TypeError(\"Sync method requested but async result obtained\");\n        }() : f : !s && t.throwOnBadSyncType ? function () {\n          throw new TypeError(\"Async method requested but sync result obtained\");\n        }() : s ? f : Promise.resolve(f);\n      };\n\n      this.reviveSync = function (e, n) {\n        return h(e, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, n, {\n          sync: !0\n        }));\n      }, this.reviveAsync = function (e, n) {\n        return h(e, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, n, {\n          sync: !1\n        }));\n      }, this.register = function (e, n) {\n        return n = n || {}, [].concat(e).forEach(function R(e) {\n          if (i(e)) return e.map(R);\n          e && r(e).forEach(function (t) {\n            if (\"#\" === t) throw new TypeError(\"# cannot be used as a type name as it is reserved for cyclic objects\");\n            if (Typeson.JSON_TYPES.includes(t)) throw new TypeError(\"Plain JSON object types are reserved as type names\");\n            var r = e[t],\n                o = r.testPlainObjects ? s : c,\n                u = o.filter(function (e) {\n              return e.type === t;\n            });\n\n            if (u.length && (o.splice(o.indexOf(u[0]), 1), delete a[t], delete y[t]), r) {\n              if (\"function\" == typeof r) {\n                var p = r;\n                r = {\n                  test: function test(e) {\n                    return e && e.constructor === p;\n                  },\n                  replace: function replace(e) {\n                    return assign({}, e);\n                  },\n                  revive: function revive(e) {\n                    return assign(Object.create(p.prototype), e);\n                  }\n                };\n              } else i(r) && (r = {\n                test: r[0],\n                replace: r[1],\n                revive: r[2]\n              });\n\n              var f = {\n                type: t,\n                test: r.test.bind(r)\n              };\n              r.replace && (f.replace = r.replace.bind(r)), r.replaceAsync && (f.replaceAsync = r.replaceAsync.bind(r));\n              var l = \"number\" == typeof n.fallback ? n.fallback : n.fallback ? 0 : 1 / 0;\n\n              if (r.testPlainObjects ? s.splice(l, 0, f) : c.splice(l, 0, f), r.revive || r.reviveAsync) {\n                var h = {};\n                r.revive && (h.revive = r.revive.bind(r)), r.reviveAsync && (h.reviveAsync = r.reviveAsync.bind(r)), a[t] = h;\n              }\n\n              y[t] = r;\n            }\n          });\n        }), this;\n      };\n    }\n\n    function assign(e, n) {\n      return r(n).map(function (t) {\n        e[t] = n[t];\n      }), e;\n    }\n\n    function escapeKeyPathComponent(e) {\n      return e.replace(/~/g, \"~0\").replace(/\\./g, \"~1\");\n    }\n\n    function unescapeKeyPathComponent(e) {\n      return e.replace(/~1/g, \".\").replace(/~0/g, \"~\");\n    }\n\n    function getByKeyPath(e, n) {\n      if (\"\" === n) return e;\n      var t = n.indexOf(\".\");\n\n      if (t > -1) {\n        var r = e[unescapeKeyPathComponent(n.substr(0, t))];\n        return void 0 === r ? void 0 : getByKeyPath(r, n.substr(t + 1));\n      }\n\n      return e[unescapeKeyPathComponent(n)];\n    }\n\n    function Undefined() {}\n\n    function TypesonPromise(e) {\n      this.p = new Promise(e);\n    }\n\n    return TypesonPromise.prototype.then = function (e, n) {\n      var t = this;\n      return new TypesonPromise(function (r, i) {\n        t.p.then(function (n) {\n          r(e ? e(n) : n);\n        }, function (e) {\n          t.p.catch(function (e) {\n            return n ? n(e) : Promise.reject(e);\n          }).then(r, i);\n        });\n      });\n    }, TypesonPromise.prototype.catch = function (e) {\n      return this.then(null, e);\n    }, TypesonPromise.resolve = function (e) {\n      return new TypesonPromise(function (n) {\n        n(e);\n      });\n    }, TypesonPromise.reject = function (e) {\n      return new TypesonPromise(function (n, t) {\n        t(e);\n      });\n    }, [\"all\", \"race\"].map(function (e) {\n      TypesonPromise[e] = function (n) {\n        return new TypesonPromise(function (t, r) {\n          Promise[e](n.map(function (e) {\n            return e.p;\n          })).then(t, r);\n        });\n      };\n    }), Typeson.Undefined = Undefined, Typeson.Promise = TypesonPromise, Typeson.isThenable = isThenable, Typeson.toStringTag = toStringTag, Typeson.hasConstructorOf = hasConstructorOf, Typeson.isObject = isObject, Typeson.isPlainObject = isPlainObject, Typeson.isUserObject = function isUserObject(e) {\n      if (!e || \"Object\" !== toStringTag(e)) return !1;\n      var n = s(e);\n      return !n || hasConstructorOf(e, Object) || isUserObject(n);\n    }, Typeson.escapeKeyPathComponent = escapeKeyPathComponent, Typeson.unescapeKeyPathComponent = unescapeKeyPathComponent, Typeson.getByKeyPath = getByKeyPath, Typeson.getJSONType = function (n) {\n      return null === n ? \"null\" : i(n) ? \"array\" : void 0 === n ? \"undefined\" : e(n);\n    }, Typeson.JSON_TYPES = [\"null\", \"boolean\", \"number\", \"string\", \"array\", \"object\"], Typeson;\n  });\n});\nvar structuredCloning = createCommonjsModule(function (module, exports) {\n  !function (e, t) {\n    module.exports = t();\n  }(commonjsGlobal, function () {\n    var e = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    },\n        t = function () {\n      return function (e, t) {\n        if (Array.isArray(e)) return e;\n        if (Symbol.iterator in Object(e)) return function sliceIterator(e, t) {\n          var n = [],\n              r = !0,\n              i = !1,\n              o = void 0;\n\n          try {\n            for (var s, a = e[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); r = !0) {\n              ;\n            }\n          } catch (e) {\n            i = !0, o = e;\n          } finally {\n            try {\n              !r && a.return && a.return();\n            } finally {\n              if (i) throw o;\n            }\n          }\n\n          return n;\n        }(e, t);\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      };\n    }(),\n        n = function n(e) {\n      if (Array.isArray(e)) {\n        for (var t = 0, n = Array(e.length); t < e.length; t++) {\n          n[t] = e[t];\n        }\n\n        return n;\n      }\n\n      return Array.from(e);\n    },\n        r = Object.keys,\n        i = Array.isArray,\n        o = {}.toString,\n        s = Object.getPrototypeOf,\n        a = {}.hasOwnProperty,\n        c = a.toString,\n        u = [\"type\", \"replaced\", \"iterateIn\", \"iterateUnsetNumeric\"];\n\n    function isThenable(e, t) {\n      return Typeson.isObject(e) && \"function\" == typeof e.then && (!t || \"function\" == typeof e.catch);\n    }\n\n    function toStringTag(e) {\n      return o.call(e).slice(8, -1);\n    }\n\n    function hasConstructorOf(t, n) {\n      if (!t || \"object\" !== (void 0 === t ? \"undefined\" : e(t))) return !1;\n      var r = s(t);\n      if (!r) return !1;\n      var i = a.call(r, \"constructor\") && r.constructor;\n      return \"function\" != typeof i ? null === n : \"function\" == typeof i && null !== n && c.call(i) === c.call(n);\n    }\n\n    function isPlainObject(e) {\n      return !(!e || \"Object\" !== toStringTag(e)) && (!s(e) || hasConstructorOf(e, Object));\n    }\n\n    function isObject(t) {\n      return t && \"object\" === (void 0 === t ? \"undefined\" : e(t));\n    }\n\n    function Typeson(o) {\n      var s = [],\n          a = [],\n          c = {},\n          f = this.types = {},\n          p = this.stringify = function (e, t, n, r) {\n        r = Object.assign({}, o, r, {\n          stringification: !0\n        });\n        var s = y(e, null, r);\n        return i(s) ? JSON.stringify(s[0], t, n) : s.then(function (e) {\n          return JSON.stringify(e, t, n);\n        });\n      };\n\n      this.stringifySync = function (e, t, n, r) {\n        return p(e, t, n, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, r, {\n          sync: !0\n        }));\n      }, this.stringifyAsync = function (e, t, n, r) {\n        return p(e, t, n, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, r, {\n          sync: !1\n        }));\n      };\n\n      var l = this.parse = function (e, t, n) {\n        return n = Object.assign({}, o, n, {\n          parse: !0\n        }), v(JSON.parse(e, t), n);\n      };\n\n      this.parseSync = function (e, t, n) {\n        return l(e, t, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, n, {\n          sync: !0\n        }));\n      }, this.parseAsync = function (e, t, n) {\n        return l(e, t, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, n, {\n          sync: !1\n        }));\n      }, this.specialTypeNames = function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n        return n.returnTypeNames = !0, this.encapsulate(e, t, n);\n      }, this.rootTypeName = function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n        return n.iterateNone = !0, this.encapsulate(e, t, n);\n      };\n\n      var y = this.encapsulate = function (f, p, l) {\n        var y = (l = Object.assign({\n          sync: !0\n        }, o, l)).sync,\n            v = {},\n            d = [],\n            h = [],\n            g = [],\n            b = !(l && \"cyclic\" in l) || l.cyclic,\n            m = l.encapsulateObserver,\n            T = _encapsulate(\"\", f, b, p || {}, g);\n\n        function finish(e) {\n          var t = Object.values(v);\n          if (l.iterateNone) return t.length ? t[0] : Typeson.getJSONType(e);\n\n          if (t.length) {\n            if (l.returnTypeNames) return [].concat(n(new Set(t)));\n            e && isPlainObject(e) && !e.hasOwnProperty(\"$types\") ? e.$types = v : e = {\n              $: e,\n              $types: {\n                $: v\n              }\n            };\n          } else isObject(e) && e.hasOwnProperty(\"$types\") && (e = {\n            $: e,\n            $types: !0\n          });\n\n          return !l.returnTypeNames && e;\n        }\n\n        return g.length ? y && l.throwOnBadSyncType ? function () {\n          throw new TypeError(\"Sync method requested but async result obtained\");\n        }() : Promise.resolve(function checkPromises(e, n) {\n          return Promise.all(n.map(function (e) {\n            return e[1].p;\n          })).then(function (r) {\n            return Promise.all(r.map(function (r) {\n              var i = [],\n                  o = n.splice(0, 1)[0],\n                  s = t(o, 7),\n                  a = s[0],\n                  c = s[2],\n                  u = s[3],\n                  f = s[4],\n                  p = s[5],\n                  l = s[6],\n                  y = _encapsulate(a, r, c, u, i, !0, l),\n                  v = hasConstructorOf(y, TypesonPromise);\n\n              return a && v ? y.p.then(function (t) {\n                return f[p] = t, checkPromises(e, i);\n              }) : (a ? f[p] = y : e = v ? y.p : y, checkPromises(e, i));\n            }));\n          }).then(function () {\n            return e;\n          });\n        }(T, g)).then(finish) : !y && l.throwOnBadSyncType ? function () {\n          throw new TypeError(\"Async method requested but sync result obtained\");\n        }() : l.stringification && y ? [finish(T)] : y ? finish(T) : Promise.resolve(finish(T));\n\n        function _adaptBuiltinStateObjectProperties(e, t, n) {\n          Object.assign(e, t);\n          var r = u.map(function (t) {\n            var n = e[t];\n            return delete e[t], n;\n          });\n          n(), u.forEach(function (t, n) {\n            e[t] = r[n];\n          });\n        }\n\n        function _encapsulate(t, n, o, a, c, u, f) {\n          var p = void 0,\n              y = {},\n              g = void 0 === n ? \"undefined\" : e(n),\n              b = m ? function (e) {\n            var r = f || a.type || Typeson.getJSONType(n);\n            m(Object.assign(e || y, {\n              keypath: t,\n              value: n,\n              cyclic: o,\n              stateObj: a,\n              promisesData: c,\n              resolvingTypesonPromise: u,\n              awaitingTypesonPromise: hasConstructorOf(n, TypesonPromise)\n            }, void 0 !== r ? {\n              type: r\n            } : {}));\n          } : null;\n          if (g in {\n            string: 1,\n            boolean: 1,\n            number: 1,\n            undefined: 1\n          }) return void 0 === n || \"number\" === g && (isNaN(n) || n === -1 / 0 || n === 1 / 0) ? (p = replace(t, n, a, c, !1, u, b)) !== n && (y = {\n            replaced: p\n          }) : p = n, b && b(), p;\n          if (null === n) return b && b(), n;\n\n          if (o && !a.iterateIn && !a.iterateUnsetNumeric) {\n            var T = d.indexOf(n);\n            if (!(T < 0)) return v[t] = \"#\", b && b({\n              cyclicKeypath: h[T]\n            }), \"#\" + h[T];\n            !0 === o && (d.push(n), h.push(t));\n          }\n\n          var O = isPlainObject(n),\n              w = i(n),\n              S = (O || w) && (!s.length || a.replaced) || a.iterateIn ? n : replace(t, n, a, c, O || w, null, b),\n              P = void 0;\n          if (S !== n ? (p = S, y = {\n            replaced: S\n          }) : w || \"array\" === a.iterateIn ? (P = new Array(n.length), y = {\n            clone: P\n          }) : O || \"object\" === a.iterateIn ? y = {\n            clone: P = {}\n          } : \"\" === t && hasConstructorOf(n, TypesonPromise) ? (c.push([t, n, o, a, void 0, void 0, a.type]), p = n) : p = n, b && b(), l.iterateNone) return P || p;\n          if (!P) return p;\n\n          if (a.iterateIn) {\n            var j = function _loop(e) {\n              var r = {\n                ownKeys: n.hasOwnProperty(e)\n              };\n\n              _adaptBuiltinStateObjectProperties(a, r, function () {\n                var r = t + (t ? \".\" : \"\") + escapeKeyPathComponent(e),\n                    i = _encapsulate(r, n[e], !!o, a, c, u);\n\n                hasConstructorOf(i, TypesonPromise) ? c.push([r, i, !!o, a, P, e, a.type]) : void 0 !== i && (P[e] = i);\n              });\n            };\n\n            for (var A in n) {\n              j(A);\n            }\n\n            b && b({\n              endIterateIn: !0,\n              end: !0\n            });\n          } else r(n).forEach(function (e) {\n            var r = t + (t ? \".\" : \"\") + escapeKeyPathComponent(e);\n\n            _adaptBuiltinStateObjectProperties(a, {\n              ownKeys: !0\n            }, function () {\n              var t = _encapsulate(r, n[e], !!o, a, c, u);\n\n              hasConstructorOf(t, TypesonPromise) ? c.push([r, t, !!o, a, P, e, a.type]) : void 0 !== t && (P[e] = t);\n            });\n          }), b && b({\n            endIterateOwn: !0,\n            end: !0\n          });\n\n          if (a.iterateUnsetNumeric) {\n            for (var C = n.length, N = function _loop2(e) {\n              if (!(e in n)) {\n                var r = t + (t ? \".\" : \"\") + e;\n\n                _adaptBuiltinStateObjectProperties(a, {\n                  ownKeys: !1\n                }, function () {\n                  var t = _encapsulate(r, void 0, !!o, a, c, u);\n\n                  hasConstructorOf(t, TypesonPromise) ? c.push([r, t, !!o, a, P, e, a.type]) : void 0 !== t && (P[e] = t);\n                });\n              }\n            }, B = 0; B < C; B++) {\n              N(B);\n            }\n\n            b && b({\n              endIterateUnsetNumeric: !0,\n              end: !0\n            });\n          }\n\n          return P;\n        }\n\n        function replace(e, t, n, r, i, o, u) {\n          for (var f = i ? s : a, p = f.length; p--;) {\n            var l = f[p];\n\n            if (l.test(t, n)) {\n              var d = l.type;\n\n              if (c[d]) {\n                var h = v[e];\n                v[e] = h ? [d].concat(h) : d;\n              }\n\n              return Object.assign(n, {\n                type: d,\n                replaced: !0\n              }), !y && l.replaceAsync || l.replace ? (u && u({\n                replacing: !0\n              }), _encapsulate(e, l[y || !l.replaceAsync ? \"replace\" : \"replaceAsync\"](t, n), b && \"readonly\", n, r, o, d)) : (u && u({\n                typeDetected: !0\n              }), _encapsulate(e, t, b && \"readonly\", n, r, o, d));\n            }\n          }\n\n          return t;\n        }\n      };\n\n      this.encapsulateSync = function (e, t, n) {\n        return y(e, t, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, n, {\n          sync: !0\n        }));\n      }, this.encapsulateAsync = function (e, t, n) {\n        return y(e, t, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, n, {\n          sync: !1\n        }));\n      };\n\n      var v = this.revive = function (e, n) {\n        var s = (n = Object.assign({\n          sync: !0\n        }, o, n)).sync,\n            a = e && e.$types,\n            u = !0;\n        if (!a) return e;\n        if (!0 === a) return e.$;\n        a.$ && isPlainObject(a.$) && (e = e.$, a = a.$, u = !1);\n\n        var f = [],\n            p = {},\n            l = function _revive(e, n, o, s, l, y) {\n          if (u && \"$types\" === e) return;\n          var v = a[e];\n\n          if (i(n) || isPlainObject(n)) {\n            var d = i(n) ? new Array(n.length) : {};\n\n            for (r(n).forEach(function (t) {\n              var r = _revive(e + (e ? \".\" : \"\") + escapeKeyPathComponent(t), n[t], o || d, s, d, t);\n\n              hasConstructorOf(r, Undefined) ? d[t] = void 0 : void 0 !== r && (d[t] = r);\n            }), n = d; f.length;) {\n              var h = t(f[0], 4),\n                  g = h[0],\n                  b = h[1],\n                  m = h[2],\n                  T = h[3],\n                  O = getByKeyPath(g, b);\n              if (hasConstructorOf(O, Undefined)) m[T] = void 0;else {\n                if (void 0 === O) break;\n                m[T] = O;\n              }\n              f.splice(0, 1);\n            }\n          }\n\n          if (!v) return n;\n\n          if (\"#\" === v) {\n            var w = getByKeyPath(o, n.substr(1));\n            return void 0 === w && f.push([o, n.substr(1), l, y]), w;\n          }\n\n          var S = s.sync;\n          return [].concat(v).reduce(function (e, t) {\n            var n = c[t];\n            if (!n) throw new Error(\"Unregistered type: \" + t);\n            return n[S && n.revive ? \"revive\" : !S && n.reviveAsync ? \"reviveAsync\" : \"revive\"](e, p);\n          }, n);\n        }(\"\", e, null, n);\n\n        return isThenable(l = hasConstructorOf(l, Undefined) ? void 0 : l) ? s && n.throwOnBadSyncType ? function () {\n          throw new TypeError(\"Sync method requested but async result obtained\");\n        }() : l : !s && n.throwOnBadSyncType ? function () {\n          throw new TypeError(\"Async method requested but sync result obtained\");\n        }() : s ? l : Promise.resolve(l);\n      };\n\n      this.reviveSync = function (e, t) {\n        return v(e, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, t, {\n          sync: !0\n        }));\n      }, this.reviveAsync = function (e, t) {\n        return v(e, Object.assign({}, {\n          throwOnBadSyncType: !0\n        }, t, {\n          sync: !1\n        }));\n      }, this.register = function (e, t) {\n        return t = t || {}, [].concat(e).forEach(function R(e) {\n          if (i(e)) return e.map(R);\n          e && r(e).forEach(function (n) {\n            if (\"#\" === n) throw new TypeError(\"# cannot be used as a type name as it is reserved for cyclic objects\");\n            if (Typeson.JSON_TYPES.includes(n)) throw new TypeError(\"Plain JSON object types are reserved as type names\");\n            var r = e[n],\n                o = r.testPlainObjects ? s : a,\n                u = o.filter(function (e) {\n              return e.type === n;\n            });\n\n            if (u.length && (o.splice(o.indexOf(u[0]), 1), delete c[n], delete f[n]), r) {\n              if (\"function\" == typeof r) {\n                var p = r;\n                r = {\n                  test: function test(e) {\n                    return e && e.constructor === p;\n                  },\n                  replace: function replace(e) {\n                    return assign({}, e);\n                  },\n                  revive: function revive(e) {\n                    return assign(Object.create(p.prototype), e);\n                  }\n                };\n              } else i(r) && (r = {\n                test: r[0],\n                replace: r[1],\n                revive: r[2]\n              });\n\n              var l = {\n                type: n,\n                test: r.test.bind(r)\n              };\n              r.replace && (l.replace = r.replace.bind(r)), r.replaceAsync && (l.replaceAsync = r.replaceAsync.bind(r));\n              var y = \"number\" == typeof t.fallback ? t.fallback : t.fallback ? 0 : 1 / 0;\n\n              if (r.testPlainObjects ? s.splice(y, 0, l) : a.splice(y, 0, l), r.revive || r.reviveAsync) {\n                var v = {};\n                r.revive && (v.revive = r.revive.bind(r)), r.reviveAsync && (v.reviveAsync = r.reviveAsync.bind(r)), c[n] = v;\n              }\n\n              f[n] = r;\n            }\n          });\n        }), this;\n      };\n    }\n\n    function assign(e, t) {\n      return r(t).map(function (n) {\n        e[n] = t[n];\n      }), e;\n    }\n\n    function escapeKeyPathComponent(e) {\n      return e.replace(/~/g, \"~0\").replace(/\\./g, \"~1\");\n    }\n\n    function unescapeKeyPathComponent(e) {\n      return e.replace(/~1/g, \".\").replace(/~0/g, \"~\");\n    }\n\n    function getByKeyPath(e, t) {\n      if (\"\" === t) return e;\n      var n = t.indexOf(\".\");\n\n      if (n > -1) {\n        var r = e[unescapeKeyPathComponent(t.substr(0, n))];\n        return void 0 === r ? void 0 : getByKeyPath(r, t.substr(n + 1));\n      }\n\n      return e[unescapeKeyPathComponent(t)];\n    }\n\n    function Undefined() {}\n\n    function TypesonPromise(e) {\n      this.p = new Promise(e);\n    }\n\n    TypesonPromise.prototype.then = function (e, t) {\n      var n = this;\n      return new TypesonPromise(function (r, i) {\n        n.p.then(function (t) {\n          r(e ? e(t) : t);\n        }, function (e) {\n          n.p.catch(function (e) {\n            return t ? t(e) : Promise.reject(e);\n          }).then(r, i);\n        });\n      });\n    }, TypesonPromise.prototype.catch = function (e) {\n      return this.then(null, e);\n    }, TypesonPromise.resolve = function (e) {\n      return new TypesonPromise(function (t) {\n        t(e);\n      });\n    }, TypesonPromise.reject = function (e) {\n      return new TypesonPromise(function (t, n) {\n        n(e);\n      });\n    }, [\"all\", \"race\"].map(function (e) {\n      TypesonPromise[e] = function (t) {\n        return new TypesonPromise(function (n, r) {\n          Promise[e](t.map(function (e) {\n            return e.p;\n          })).then(n, r);\n        });\n      };\n    }), Typeson.Undefined = Undefined, Typeson.Promise = TypesonPromise, Typeson.isThenable = isThenable, Typeson.toStringTag = toStringTag, Typeson.hasConstructorOf = hasConstructorOf, Typeson.isObject = isObject, Typeson.isPlainObject = isPlainObject, Typeson.isUserObject = function isUserObject(e) {\n      if (!e || \"Object\" !== toStringTag(e)) return !1;\n      var t = s(e);\n      return !t || hasConstructorOf(e, Object) || isUserObject(t);\n    }, Typeson.escapeKeyPathComponent = escapeKeyPathComponent, Typeson.unescapeKeyPathComponent = unescapeKeyPathComponent, Typeson.getByKeyPath = getByKeyPath, Typeson.getJSONType = function (t) {\n      return null === t ? \"null\" : i(t) ? \"array\" : void 0 === t ? \"undefined\" : e(t);\n    }, Typeson.JSON_TYPES = [\"null\", \"boolean\", \"number\", \"string\", \"array\", \"object\"];\n\n    for (var f = {\n      userObject: {\n        test: function test(e, t) {\n          return Typeson.isUserObject(e);\n        },\n        replace: function replace(e) {\n          return Object.assign({}, e);\n        },\n        revive: function revive(e) {\n          return e;\n        }\n      }\n    }, p = [[{\n      sparseArrays: {\n        testPlainObjects: !0,\n        test: function test(e) {\n          return Array.isArray(e);\n        },\n        replace: function replace(e, t) {\n          return t.iterateUnsetNumeric = !0, e;\n        }\n      }\n    }, {\n      sparseUndefined: {\n        test: function test(e, t) {\n          return void 0 === e && !1 === t.ownKeys;\n        },\n        replace: function replace(e) {\n          return null;\n        },\n        revive: function revive(e) {}\n      }\n    }], {\n      undef: {\n        test: function test(e, t) {\n          return void 0 === e && (t.ownKeys || !(\"ownKeys\" in t));\n        },\n        replace: function replace(e) {\n          return null;\n        },\n        revive: function revive(e) {\n          return new Typeson.Undefined();\n        }\n      }\n    }], l = {\n      StringObject: {\n        test: function test(t) {\n          return \"String\" === Typeson.toStringTag(t) && \"object\" === (void 0 === t ? \"undefined\" : e(t));\n        },\n        replace: function replace(e) {\n          return String(e);\n        },\n        revive: function revive(e) {\n          return new String(e);\n        }\n      },\n      BooleanObject: {\n        test: function test(t) {\n          return \"Boolean\" === Typeson.toStringTag(t) && \"object\" === (void 0 === t ? \"undefined\" : e(t));\n        },\n        replace: function replace(e) {\n          return Boolean(e);\n        },\n        revive: function revive(e) {\n          return new Boolean(e);\n        }\n      },\n      NumberObject: {\n        test: function test(t) {\n          return \"Number\" === Typeson.toStringTag(t) && \"object\" === (void 0 === t ? \"undefined\" : e(t));\n        },\n        replace: function replace(e) {\n          return Number(e);\n        },\n        revive: function revive(e) {\n          return new Number(e);\n        }\n      }\n    }, y = [{\n      nan: {\n        test: function test(e) {\n          return \"number\" == typeof e && isNaN(e);\n        },\n        replace: function replace(e) {\n          return \"NaN\";\n        },\n        revive: function revive(e) {\n          return NaN;\n        }\n      }\n    }, {\n      infinity: {\n        test: function test(e) {\n          return e === 1 / 0;\n        },\n        replace: function replace(e) {\n          return \"Infinity\";\n        },\n        revive: function revive(e) {\n          return 1 / 0;\n        }\n      }\n    }, {\n      negativeInfinity: {\n        test: function test(e) {\n          return e === -1 / 0;\n        },\n        replace: function replace(e) {\n          return \"-Infinity\";\n        },\n        revive: function revive(e) {\n          return -1 / 0;\n        }\n      }\n    }], v = {\n      date: {\n        test: function test(e) {\n          return \"Date\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e) {\n          var t = e.getTime();\n          return isNaN(t) ? \"NaN\" : t;\n        },\n        revive: function revive(e) {\n          return \"NaN\" === e ? new Date(NaN) : new Date(e);\n        }\n      }\n    }, d = {\n      regexp: {\n        test: function test(e) {\n          return \"RegExp\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e) {\n          return {\n            source: e.source,\n            flags: (e.global ? \"g\" : \"\") + (e.ignoreCase ? \"i\" : \"\") + (e.multiline ? \"m\" : \"\") + (e.sticky ? \"y\" : \"\") + (e.unicode ? \"u\" : \"\")\n          };\n        },\n        revive: function revive(e) {\n          var t = e.source,\n              n = e.flags;\n          return new RegExp(t, n);\n        }\n      }\n    }, h = {\n      map: {\n        test: function test(e) {\n          return \"Map\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e) {\n          return Array.from(e.entries());\n        },\n        revive: function revive(e) {\n          return new Map(e);\n        }\n      }\n    }, g = {\n      set: {\n        test: function test(e) {\n          return \"Set\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e) {\n          return Array.from(e.values());\n        },\n        revive: function revive(e) {\n          return new Set(e);\n        }\n      }\n    }, b = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", m = new Uint8Array(256), T = 0; T < b.length; T++) {\n      m[b.charCodeAt(T)] = T;\n    }\n\n    var O = function encode(e, t, n) {\n      for (var r = new Uint8Array(e, t, n), i = r.length, o = \"\", s = 0; s < i; s += 3) {\n        o += b[r[s] >> 2], o += b[(3 & r[s]) << 4 | r[s + 1] >> 4], o += b[(15 & r[s + 1]) << 2 | r[s + 2] >> 6], o += b[63 & r[s + 2]];\n      }\n\n      return i % 3 == 2 ? o = o.substring(0, o.length - 1) + \"=\" : i % 3 == 1 && (o = o.substring(0, o.length - 2) + \"==\"), o;\n    },\n        w = function decode(e) {\n      var t = e.length,\n          n = .75 * e.length,\n          r = 0,\n          i = void 0,\n          o = void 0,\n          s = void 0,\n          a = void 0;\n      \"=\" === e[e.length - 1] && (n--, \"=\" === e[e.length - 2] && n--);\n\n      for (var c = new ArrayBuffer(n), u = new Uint8Array(c), f = 0; f < t; f += 4) {\n        i = m[e.charCodeAt(f)], o = m[e.charCodeAt(f + 1)], s = m[e.charCodeAt(f + 2)], a = m[e.charCodeAt(f + 3)], u[r++] = i << 2 | o >> 4, u[r++] = (15 & o) << 4 | s >> 2, u[r++] = (3 & s) << 6 | 63 & a;\n      }\n\n      return c;\n    },\n        S = {\n      arraybuffer: {\n        test: function test(e) {\n          return \"ArrayBuffer\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e, t) {\n          t.buffers || (t.buffers = []);\n          var n = t.buffers.indexOf(e);\n          return n > -1 ? {\n            index: n\n          } : (t.buffers.push(e), O(e));\n        },\n        revive: function revive(t, n) {\n          if (n.buffers || (n.buffers = []), \"object\" === (void 0 === t ? \"undefined\" : e(t))) return n.buffers[t.index];\n          var r = w(t);\n          return n.buffers.push(r), r;\n        }\n      }\n    },\n        P = \"undefined\" == typeof self ? commonjsGlobal : self,\n        j = {};\n\n    [\"Int8Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Int16Array\", \"Uint16Array\", \"Int32Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\"].forEach(function (e) {\n      var t = e,\n          n = P[t];\n      n && (j[e.toLowerCase()] = {\n        test: function test(e) {\n          return Typeson.toStringTag(e) === t;\n        },\n        replace: function replace(e, t) {\n          var n = e.buffer,\n              r = e.byteOffset,\n              i = e.length;\n          t.buffers || (t.buffers = []);\n          var o = t.buffers.indexOf(n);\n          return o > -1 ? {\n            index: o,\n            byteOffset: r,\n            length: i\n          } : (t.buffers.push(n), {\n            encoded: O(n),\n            byteOffset: r,\n            length: i\n          });\n        },\n        revive: function revive(e, t) {\n          t.buffers || (t.buffers = []);\n          var r = e.byteOffset,\n              i = e.length,\n              o = e.encoded,\n              s = e.index,\n              a = void 0;\n          return \"index\" in e ? a = t.buffers[s] : (a = w(o), t.buffers.push(a)), new n(a, r, i);\n        }\n      });\n    });\n    var A = {\n      dataview: {\n        test: function test(e) {\n          return \"DataView\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e, t) {\n          var n = e.buffer,\n              r = e.byteOffset,\n              i = e.byteLength;\n          t.buffers || (t.buffers = []);\n          var o = t.buffers.indexOf(n);\n          return o > -1 ? {\n            index: o,\n            byteOffset: r,\n            byteLength: i\n          } : (t.buffers.push(n), {\n            encoded: O(n),\n            byteOffset: r,\n            byteLength: i\n          });\n        },\n        revive: function revive(e, t) {\n          t.buffers || (t.buffers = []);\n          var n = e.byteOffset,\n              r = e.byteLength,\n              i = e.encoded,\n              o = e.index,\n              s = void 0;\n          return \"index\" in e ? s = t.buffers[o] : (s = w(i), t.buffers.push(s)), new DataView(s, n, r);\n        }\n      }\n    },\n        C = {\n      IntlCollator: {\n        test: function test(e) {\n          return Typeson.hasConstructorOf(e, Intl.Collator);\n        },\n        replace: function replace(e) {\n          return e.resolvedOptions();\n        },\n        revive: function revive(e) {\n          return new Intl.Collator(e.locale, e);\n        }\n      },\n      IntlDateTimeFormat: {\n        test: function test(e) {\n          return Typeson.hasConstructorOf(e, Intl.DateTimeFormat);\n        },\n        replace: function replace(e) {\n          return e.resolvedOptions();\n        },\n        revive: function revive(e) {\n          return new Intl.DateTimeFormat(e.locale, e);\n        }\n      },\n      IntlNumberFormat: {\n        test: function test(e) {\n          return Typeson.hasConstructorOf(e, Intl.NumberFormat);\n        },\n        replace: function replace(e) {\n          return e.resolvedOptions();\n        },\n        revive: function revive(e) {\n          return new Intl.NumberFormat(e.locale, e);\n        }\n      }\n    };\n\n    function string2arraybuffer(e) {\n      for (var t = new Uint16Array(e.length), n = 0; n < e.length; n++) {\n        t[n] = e.charCodeAt(n);\n      }\n\n      return t.buffer;\n    }\n\n    var N = {\n      file: {\n        test: function test(e) {\n          return \"File\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e) {\n          var t = new XMLHttpRequest();\n          if (t.open(\"GET\", URL.createObjectURL(e), !1), \"undefined\" != typeof TextEncoder && t.overrideMimeType(\"text/plain; charset=utf-16le\"), 200 !== t.status && 0 !== t.status) throw new Error(\"Bad Blob access: \" + t.status);\n          return t.send(), {\n            type: e.type,\n            stringContents: t.responseText,\n            name: e.name,\n            lastModified: e.lastModified\n          };\n        },\n        revive: function revive(e) {\n          var t = e.name,\n              n = e.type,\n              r = e.stringContents,\n              i = e.lastModified,\n              o = string2arraybuffer(r);\n          return new File([o], t, {\n            type: n,\n            lastModified: i\n          });\n        },\n        replaceAsync: function replaceAsync(e) {\n          return new Typeson.Promise(function (t, n) {\n            if (e.isClosed) n(new Error(\"The File is closed\"));else {\n              var r = new FileReader();\n              r.addEventListener(\"load\", function () {\n                t({\n                  type: e.type,\n                  stringContents: r.result,\n                  name: e.name,\n                  lastModified: e.lastModified\n                });\n              }), r.addEventListener(\"error\", function () {\n                n(r.error);\n              }), r.readAsText(e, \"UTF-16\");\n            }\n          });\n        }\n      }\n    };\n    return [f, p, l, y, v, d, {\n      imagedata: {\n        test: function test(e) {\n          return \"ImageData\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e) {\n          return {\n            array: Array.from(e.data),\n            width: e.width,\n            height: e.height\n          };\n        },\n        revive: function revive(e) {\n          return new ImageData(new Uint8ClampedArray(e.array), e.width, e.height);\n        }\n      }\n    }, {\n      imagebitmap: {\n        test: function test(e) {\n          return \"ImageBitmap\" === Typeson.toStringTag(e) || e && e.dataset && \"ImageBitmap\" === e.dataset.toStringTag;\n        },\n        replace: function replace(e) {\n          var t = document.createElement(\"canvas\");\n          return t.getContext(\"2d\").drawImage(e, 0, 0), t.toDataURL();\n        },\n        revive: function revive(e) {\n          var t = document.createElement(\"canvas\"),\n              n = t.getContext(\"2d\"),\n              r = document.createElement(\"img\");\n          return r.onload = function () {\n            n.drawImage(r, 0, 0);\n          }, r.src = e, t;\n        },\n        reviveAsync: function reviveAsync(e) {\n          var t = document.createElement(\"canvas\"),\n              n = t.getContext(\"2d\"),\n              r = document.createElement(\"img\");\n          return r.onload = function () {\n            n.drawImage(r, 0, 0);\n          }, r.src = e, createImageBitmap(t);\n        }\n      }\n    }, N, {\n      file: N.file,\n      filelist: {\n        test: function test(e) {\n          return \"FileList\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e) {\n          for (var t = [], n = 0; n < e.length; n++) {\n            t[n] = e.item(n);\n          }\n\n          return t;\n        },\n        revive: function revive(e) {\n          function FileList() {\n            this._files = arguments[0], this.length = this._files.length;\n          }\n\n          return FileList.prototype.item = function (e) {\n            return this._files[e];\n          }, FileList.prototype[Symbol.toStringTag] = \"FileList\", new FileList(e);\n        }\n      }\n    }, {\n      blob: {\n        test: function test(e) {\n          return \"Blob\" === Typeson.toStringTag(e);\n        },\n        replace: function replace(e) {\n          var t = new XMLHttpRequest();\n          if (t.open(\"GET\", URL.createObjectURL(e), !1), \"undefined\" != typeof TextEncoder && t.overrideMimeType(\"text/plain; charset=utf-16le\"), 200 !== t.status && 0 !== t.status) throw new Error(\"Bad Blob access: \" + t.status);\n          return t.send(), {\n            type: e.type,\n            stringContents: t.responseText\n          };\n        },\n        revive: function revive(e) {\n          var t = e.type,\n              n = e.stringContents;\n          return new Blob([string2arraybuffer(n)], {\n            type: t\n          });\n        },\n        replaceAsync: function replaceAsync(e) {\n          return new Typeson.Promise(function (t, n) {\n            if (e.isClosed) n(new Error(\"The Blob is closed\"));else {\n              var r = new FileReader();\n              r.addEventListener(\"load\", function () {\n                t({\n                  type: e.type,\n                  stringContents: r.result\n                });\n              }), r.addEventListener(\"error\", function () {\n                n(r.error);\n              }), r.readAsText(e, \"UTF-16\");\n            }\n          });\n        }\n      }\n    }].concat(\"function\" == typeof Map ? h : [], \"function\" == typeof Set ? g : [], \"function\" == typeof ArrayBuffer ? S : [], \"function\" == typeof Uint8Array ? j : [], \"function\" == typeof DataView ? A : [], \"undefined\" != typeof Intl ? C : []);\n  });\n});\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2017 Brett Zamir, 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // Use a lookup table to find the index.\n\nvar lookup = new Uint8Array(256);\n\nfor (var i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\n\nvar encode = function encode(arraybuffer, byteOffset, length) {\n  if (length === null || length === undefined) {\n    length = arraybuffer.byteLength; // Needed for Safari\n  }\n\n  var bytes = new Uint8Array(arraybuffer, byteOffset || 0, // Default needed for Safari\n  length);\n  var len = bytes.length;\n  var base64 = '';\n\n  for (var _i = 0; _i < len; _i += 3) {\n    base64 += chars[bytes[_i] >> 2];\n    base64 += chars[(bytes[_i] & 3) << 4 | bytes[_i + 1] >> 4];\n    base64 += chars[(bytes[_i + 1] & 15) << 2 | bytes[_i + 2] >> 6];\n    base64 += chars[bytes[_i + 2] & 63];\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\n\nvar decode = function decode(base64) {\n  var len = base64.length;\n  var bufferLength = base64.length * 0.75;\n  var p = 0;\n  var encoded1, encoded2, encoded3, encoded4;\n\n  if (base64[base64.length - 1] === '=') {\n    bufferLength--;\n\n    if (base64[base64.length - 2] === '=') {\n      bufferLength--;\n    }\n  }\n\n  var arraybuffer = new ArrayBuffer(bufferLength),\n      bytes = new Uint8Array(arraybuffer);\n\n  for (var _i2 = 0; _i2 < len; _i2 += 4) {\n    encoded1 = lookup[base64.charCodeAt(_i2)];\n    encoded2 = lookup[base64.charCodeAt(_i2 + 1)];\n    encoded3 = lookup[base64.charCodeAt(_i2 + 2)];\n    encoded4 = lookup[base64.charCodeAt(_i2 + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n\n  return arraybuffer;\n};\n/* eslint-env browser, node */\n\n\nvar _global = typeof self === 'undefined' ? global : self;\n\nvar exportObj = {};\n['Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array'].forEach(function (typeName) {\n  var arrType = typeName;\n  var TypedArray = _global[arrType];\n\n  if (TypedArray) {\n    exportObj[typeName.toLowerCase() + \"2\"] = {\n      test: function test(x) {\n        return typeson.toStringTag(x) === arrType;\n      },\n      replace: function replace(_a) {\n        var buffer = _a.buffer,\n            byteOffset = _a.byteOffset,\n            length = _a.length;\n        return {\n          buffer: buffer,\n          byteOffset: byteOffset,\n          length: length\n        };\n      },\n      revive: function revive(b64Obj) {\n        var buffer = b64Obj.buffer,\n            byteOffset = b64Obj.byteOffset,\n            length = b64Obj.length;\n        return new TypedArray(buffer, byteOffset, length);\n      }\n    };\n  }\n});\nvar arrayBuffer = {\n  arraybuffer: {\n    test: function test(x) {\n      return typeson.toStringTag(x) === 'ArrayBuffer';\n    },\n    replace: function replace(b) {\n      return encode(b, 0, b.byteLength);\n    },\n    revive: function revive(b64) {\n      var buffer = decode(b64);\n      return buffer;\n    }\n  }\n}; // See also typed-arrays!\n\nvar TSON = new typeson().register(structuredCloning);\nvar readBlobsSynchronously = ('FileReaderSync' in self); // true in workers only.\n\nvar blobsToAwait = [];\nvar blobsToAwaitPos = 0; // Need to patch encapsulateAsync as it does not work as of typeson 5.8.2\n// Also, current version of typespn-registry-1.0.0-alpha.21 does not\n// encapsulate/revive Blobs correctly (fails one of the unit tests in\n// this library (test 'export-format'))\n\nTSON.register([arrayBuffer, exportObj, {\n  blob2: {\n    test: function test(x) {\n      return typeson.toStringTag(x) === 'Blob';\n    },\n    replace: function replace(b) {\n      if (b.isClosed) {\n        // On MDN, but not in https://w3c.github.io/FileAPI/#dfn-Blob\n        throw new Error('The Blob is closed');\n      }\n\n      if (readBlobsSynchronously) {\n        var data = readBlobSync(b, 'binary');\n        var base64 = encode(data, 0, data.byteLength);\n        return {\n          type: b.type,\n          data: base64\n        };\n      } else {\n        blobsToAwait.push(b); // This will also make TSON.mustFinalize() return true.\n\n        var result = {\n          type: b.type,\n          data: {\n            start: blobsToAwaitPos,\n            end: blobsToAwaitPos + b.size\n          }\n        };\n        console.log(\"b.size: \" + b.size);\n        blobsToAwaitPos += b.size;\n        return result;\n      }\n    },\n    finalize: function finalize(b, ba) {\n      b.data = encode(ba, 0, ba.byteLength);\n    },\n    revive: function revive(_a) {\n      var type = _a.type,\n          data = _a.data;\n      return new Blob([decode(data)], {\n        type: type\n      });\n    }\n  }\n}]);\n\nTSON.mustFinalize = function () {\n  return blobsToAwait.length > 0;\n};\n\nTSON.finalize = function (items) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var allChunks, _i, items_1, item, types, arrayType, keyPath, typeName, typeSpec, b;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , readBlobAsync(new Blob(blobsToAwait), 'binary')];\n\n        case 1:\n          allChunks = _a.sent();\n\n          if (items) {\n            for (_i = 0, items_1 = items; _i < items_1.length; _i++) {\n              item = items_1[_i]; // Manually go through all \"blob\" types in the result\n              // and lookup the data slice they point at.\n\n              if (item.$types) {\n                types = item.$types;\n                arrayType = types.$;\n                if (arrayType) types = types.$;\n\n                for (keyPath in types) {\n                  typeName = types[keyPath];\n                  typeSpec = TSON.types[typeName];\n\n                  if (typeSpec && typeSpec.finalize) {\n                    b = Dexie.getByKeyPath(item, arrayType ? \"$.\" + keyPath : keyPath);\n                    typeSpec.finalize(b, allChunks.slice(b.start, b.end));\n                  }\n                }\n              }\n            }\n          } // Free up memory\n\n\n          blobsToAwait = [];\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\n\nvar DEFAULT_ROWS_PER_CHUNK = 2000;\n\nfunction exportDB(db, options) {\n  return __awaiter(this, void 0, void 0, function () {\n    function exportAll() {\n      return __awaiter(this, void 0, void 0, function () {\n        var tablesRowCounts, emptyExportJson, posEndDataArray, firstJsonSlice, filter, _loop_1, _i, tables_1, tableName;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , Promise.all(db.tables.map(function (table) {\n                return table.count();\n              }))];\n\n            case 1:\n              tablesRowCounts = _a.sent();\n              tablesRowCounts.forEach(function (rowCount, i) {\n                return tables[i].rowCount = rowCount;\n              });\n              progress.totalRows = tablesRowCounts.reduce(function (p, c) {\n                return p + c;\n              });\n              emptyExportJson = JSON.stringify(emptyExport, undefined, prettyJson ? 2 : undefined);\n              posEndDataArray = emptyExportJson.lastIndexOf(']');\n              firstJsonSlice = emptyExportJson.substring(0, posEndDataArray);\n              slices.push(firstJsonSlice);\n              filter = options.filter;\n\n              _loop_1 = function _loop_1(tableName) {\n                var table, primKey, inbound, LIMIT, emptyTableExport, emptyTableExportJson, posEndRowsArray, lastKey, lastNumRows, mayHaveMoreRows, _loop_2, state_1;\n\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      table = db.table(tableName);\n                      primKey = table.schema.primKey;\n                      inbound = !!primKey.keyPath;\n                      LIMIT = options.numRowsPerChunk || DEFAULT_ROWS_PER_CHUNK;\n                      emptyTableExport = inbound ? {\n                        tableName: table.name,\n                        inbound: true,\n                        rows: []\n                      } : {\n                        tableName: table.name,\n                        inbound: false,\n                        rows: []\n                      };\n                      emptyTableExportJson = JSON.stringify(emptyTableExport, undefined, prettyJson ? 2 : undefined);\n\n                      if (prettyJson) {\n                        // Increase indentation according to this:\n                        // {\n                        //   ...\n                        //   data: [\n                        //     ...\n                        //     data: [\n                        // 123456<---- here\n                        //     ] \n                        //   ]\n                        // }\n                        emptyTableExportJson = emptyTableExportJson.split('\\n').join('\\n    ');\n                      }\n\n                      posEndRowsArray = emptyTableExportJson.lastIndexOf(']');\n                      slices.push(emptyTableExportJson.substring(0, posEndRowsArray));\n                      lastKey = null;\n                      lastNumRows = 0;\n                      mayHaveMoreRows = true;\n\n                      _loop_2 = function _loop_2() {\n                        var chunkedCollection, values, filteredValues, tsonValues, json, keys, keyvals, tsonTuples, json;\n                        return __generator(this, function (_a) {\n                          switch (_a.label) {\n                            case 0:\n                              if (progressCallback) {\n                                // Keep ongoing transaction private\n                                Dexie.ignoreTransaction(function () {\n                                  return progressCallback(progress);\n                                });\n                              }\n\n                              chunkedCollection = lastKey == null ? table.limit(LIMIT) : table.where(':id').above(lastKey).limit(LIMIT);\n                              return [4\n                              /*yield*/\n                              , chunkedCollection.toArray()];\n\n                            case 1:\n                              values = _a.sent();\n                              if (values.length === 0) return [2\n                              /*return*/\n                              , \"break\"];\n\n                              if (lastKey != null && lastNumRows > 0) {\n                                // Not initial chunk. Must add a comma:\n                                slices.push(\",\");\n\n                                if (prettyJson) {\n                                  slices.push(\"\\n      \");\n                                }\n                              }\n\n                              mayHaveMoreRows = values.length === LIMIT;\n                              if (!inbound) return [3\n                              /*break*/\n                              , 4];\n                              filteredValues = filter ? values.filter(function (value) {\n                                return filter(tableName, value);\n                              }) : values;\n                              tsonValues = filteredValues.map(function (value) {\n                                return TSON.encapsulate(value);\n                              });\n                              if (!TSON.mustFinalize()) return [3\n                              /*break*/\n                              , 3];\n                              return [4\n                              /*yield*/\n                              , Dexie.waitFor(TSON.finalize(tsonValues))];\n\n                            case 2:\n                              _a.sent();\n\n                              _a.label = 3;\n\n                            case 3:\n                              json = JSON.stringify(tsonValues, undefined, prettyJson ? 2 : undefined);\n                              if (prettyJson) json = json.split('\\n').join('\\n      '); // By generating a blob here, we give web platform the opportunity to store the contents\n                              // on disk and release RAM.\n\n                              slices.push(new Blob([json.substring(1, json.length - 1)]));\n                              lastNumRows = filteredValues.length;\n                              lastKey = values.length > 0 ? Dexie.getByKeyPath(values[values.length - 1], primKey.keyPath) : null;\n                              return [3\n                              /*break*/\n                              , 8];\n\n                            case 4:\n                              return [4\n                              /*yield*/\n                              , chunkedCollection.primaryKeys()];\n\n                            case 5:\n                              keys = _a.sent();\n                              keyvals = keys.map(function (key, i) {\n                                return [key, values[i]];\n                              });\n                              if (filter) keyvals = keyvals.filter(function (_a) {\n                                var key = _a[0],\n                                    value = _a[1];\n                                return filter(tableName, value, key);\n                              });\n                              tsonTuples = keyvals.map(function (tuple) {\n                                return TSON.encapsulate(tuple);\n                              });\n                              if (!TSON.mustFinalize()) return [3\n                              /*break*/\n                              , 7];\n                              return [4\n                              /*yield*/\n                              , Dexie.waitFor(TSON.finalize(tsonTuples))];\n\n                            case 6:\n                              _a.sent();\n\n                              _a.label = 7;\n\n                            case 7:\n                              json = JSON.stringify(tsonTuples, undefined, prettyJson ? 2 : undefined);\n                              if (prettyJson) json = json.split('\\n').join('\\n      '); // By generating a blob here, we give web platform the opportunity to store the contents\n                              // on disk and release RAM.\n\n                              slices.push(new Blob([json.substring(1, json.length - 1)]));\n                              lastNumRows = keyvals.length;\n                              lastKey = keys.length > 0 ? keys[keys.length - 1] : null;\n                              _a.label = 8;\n\n                            case 8:\n                              progress.completedRows += values.length;\n                              return [2\n                              /*return*/\n                              ];\n                          }\n                        });\n                      };\n\n                      _a.label = 1;\n\n                    case 1:\n                      if (!mayHaveMoreRows) return [3\n                      /*break*/\n                      , 3];\n                      return [5\n                      /*yield**/\n                      , _loop_2()];\n\n                    case 2:\n                      state_1 = _a.sent();\n                      if (state_1 === \"break\") return [3\n                      /*break*/\n                      , 3];\n                      return [3\n                      /*break*/\n                      , 1];\n\n                    case 3:\n                      slices.push(emptyTableExportJson.substr(posEndRowsArray)); // \"]}\"\n\n                      progress.completedTables += 1;\n\n                      if (progress.completedTables < progress.totalTables) {\n                        slices.push(\",\");\n                      }\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              };\n\n              _i = 0, tables_1 = tables;\n              _a.label = 2;\n\n            case 2:\n              if (!(_i < tables_1.length)) return [3\n              /*break*/\n              , 5];\n              tableName = tables_1[_i].name;\n              return [5\n              /*yield**/\n              , _loop_1(tableName)];\n\n            case 3:\n              _a.sent();\n\n              _a.label = 4;\n\n            case 4:\n              _i++;\n              return [3\n              /*break*/\n              , 2];\n\n            case 5:\n              slices.push(emptyExportJson.substr(posEndDataArray));\n              progress.done = true;\n\n              if (progressCallback) {\n                // Keep ongoing transaction private\n                Dexie.ignoreTransaction(function () {\n                  return progressCallback(progress);\n                });\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n\n    var slices, tables, prettyJson, emptyExport, progressCallback, progress;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          options = options || {};\n          slices = [];\n          tables = db.tables.map(function (table) {\n            return {\n              name: table.name,\n              schema: getSchemaString(table),\n              rowCount: 0\n            };\n          });\n          prettyJson = options.prettyJson;\n          emptyExport = {\n            formatName: \"dexie\",\n            formatVersion: 1,\n            data: {\n              databaseName: db.name,\n              databaseVersion: db.verno,\n              tables: tables,\n              data: []\n            }\n          };\n          progressCallback = options.progressCallback;\n          progress = {\n            done: false,\n            completedRows: 0,\n            completedTables: 0,\n            totalRows: NaN,\n            totalTables: db.tables.length\n          };\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1,, 6, 7]);\n\n          if (!options.noTransaction) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , exportAll()];\n\n        case 2:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 5];\n\n        case 3:\n          return [4\n          /*yield*/\n          , db.transaction('r', db.tables, exportAll)];\n\n        case 4:\n          _a.sent();\n\n          _a.label = 5;\n\n        case 5:\n          return [3\n          /*break*/\n          , 7];\n\n        case 6:\n          TSON.finalize(); // Free up mem if error has occurred\n\n          return [7\n          /*endfinally*/\n          ];\n\n        case 7:\n          if (progressCallback) {\n            // Keep ongoing transaction private\n            Dexie.ignoreTransaction(function () {\n              return progressCallback(progress);\n            });\n          }\n\n          return [2\n          /*return*/\n          , new Blob(slices, {\n            type: \"text/json\"\n          })];\n      }\n    });\n  });\n}\n\nvar VERSION = 1;\nvar fakeStream = {\n  Stream: function Stream() {}\n};\nvar clarinet_1 = createCommonjsModule(function (module, exports) {\n  (function (clarinet) {\n    // non node-js needs to set clarinet debug on root\n    var env = typeof process === 'object' && process.env ? process.env : self;\n\n    clarinet.parser = function (opt) {\n      return new CParser(opt);\n    };\n\n    clarinet.CParser = CParser;\n    clarinet.CStream = CStream;\n    clarinet.createStream = createStream;\n    clarinet.MAX_BUFFER_LENGTH = 10 * 1024 * 1024;\n    clarinet.DEBUG = env.CDEBUG === 'debug';\n    clarinet.INFO = env.CDEBUG === 'debug' || env.CDEBUG === 'info';\n    clarinet.EVENTS = [\"value\", \"string\", \"key\", \"openobject\", \"closeobject\", \"openarray\", \"closearray\", \"error\", \"end\", \"ready\"];\n    var buffers = {\n      textNode: undefined,\n      numberNode: \"\"\n    },\n        streamWraps = clarinet.EVENTS.filter(function (ev) {\n      return ev !== \"error\" && ev !== \"end\";\n    }),\n        S = 0,\n        Stream;\n    clarinet.STATE = {\n      BEGIN: S++,\n      VALUE: S++ // general stuff\n      ,\n      OPEN_OBJECT: S++ // {\n      ,\n      CLOSE_OBJECT: S++ // }\n      ,\n      OPEN_ARRAY: S++ // [\n      ,\n      CLOSE_ARRAY: S++ // ]\n      ,\n      TEXT_ESCAPE: S++ // \\ stuff\n      ,\n      STRING: S++ // \"\"\n      ,\n      BACKSLASH: S++,\n      END: S++ // No more stack\n      ,\n      OPEN_KEY: S++ // , \"a\"\n      ,\n      CLOSE_KEY: S++ // :\n      ,\n      TRUE: S++ // r\n      ,\n      TRUE2: S++ // u\n      ,\n      TRUE3: S++ // e\n      ,\n      FALSE: S++ // a\n      ,\n      FALSE2: S++ // l\n      ,\n      FALSE3: S++ // s\n      ,\n      FALSE4: S++ // e\n      ,\n      NULL: S++ // u\n      ,\n      NULL2: S++ // l\n      ,\n      NULL3: S++ // l\n      ,\n      NUMBER_DECIMAL_POINT: S++ // .\n      ,\n      NUMBER_DIGIT: S++ // [0-9]\n\n    };\n\n    for (var s_ in clarinet.STATE) {\n      clarinet.STATE[clarinet.STATE[s_]] = s_;\n    } // switcharoo\n\n\n    S = clarinet.STATE;\n    var Char = {\n      tab: 0x09,\n      // \\t\n      lineFeed: 0x0A,\n      // \\n\n      carriageReturn: 0x0D,\n      // \\r\n      space: 0x20,\n      // \" \"\n      doubleQuote: 0x22,\n      // \"\n      plus: 0x2B,\n      // +\n      comma: 0x2C,\n      // ,\n      minus: 0x2D,\n      // -\n      period: 0x2E,\n      // .\n      _0: 0x30,\n      // 0\n      _9: 0x39,\n      // 9\n      colon: 0x3A,\n      // :\n      E: 0x45,\n      // E\n      openBracket: 0x5B,\n      // [\n      backslash: 0x5C,\n      // \\\n      closeBracket: 0x5D,\n      // ]\n      a: 0x61,\n      // a\n      b: 0x62,\n      // b\n      e: 0x65,\n      // e \n      f: 0x66,\n      // f\n      l: 0x6C,\n      // l\n      n: 0x6E,\n      // n\n      r: 0x72,\n      // r\n      s: 0x73,\n      // s\n      t: 0x74,\n      // t\n      u: 0x75,\n      // u\n      openBrace: 0x7B,\n      // {\n      closeBrace: 0x7D // }\n\n    };\n\n    if (!Object.create) {\n      Object.create = function (o) {\n        function f() {\n          this[\"__proto__\"] = o;\n        }\n\n        f.prototype = o;\n        return new f();\n      };\n    }\n\n    if (!Object.getPrototypeOf) {\n      Object.getPrototypeOf = function (o) {\n        return o[\"__proto__\"];\n      };\n    }\n\n    if (!Object.keys) {\n      Object.keys = function (o) {\n        var a = [];\n\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) a.push(i);\n        }\n\n        return a;\n      };\n    }\n\n    function checkBufferLength(parser) {\n      var maxAllowed = Math.max(clarinet.MAX_BUFFER_LENGTH, 10),\n          maxActual = 0;\n\n      for (var buffer in buffers) {\n        var len = parser[buffer] === undefined ? 0 : parser[buffer].length;\n\n        if (len > maxAllowed) {\n          switch (buffer) {\n            case \"text\":\n              closeText(parser);\n              break;\n\n            default:\n              error(parser, \"Max buffer length exceeded: \" + buffer);\n          }\n        }\n\n        maxActual = Math.max(maxActual, len);\n      }\n\n      parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH - maxActual + parser.position;\n    }\n\n    function clearBuffers(parser) {\n      for (var buffer in buffers) {\n        parser[buffer] = buffers[buffer];\n      }\n    }\n\n    var stringTokenPattern = /[\\\\\"\\n]/g;\n\n    function CParser(opt) {\n      if (!(this instanceof CParser)) return new CParser(opt);\n      var parser = this;\n      clearBuffers(parser);\n      parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;\n      parser.q = parser.c = parser.p = \"\";\n      parser.opt = opt || {};\n      parser.closed = parser.closedRoot = parser.sawRoot = false;\n      parser.tag = parser.error = null;\n      parser.state = S.BEGIN;\n      parser.stack = new Array(); // mostly just for error reporting\n\n      parser.position = parser.column = 0;\n      parser.line = 1;\n      parser.slashed = false;\n      parser.unicodeI = 0;\n      parser.unicodeS = null;\n      parser.depth = 0;\n      emit(parser, \"onready\");\n    }\n\n    CParser.prototype = {\n      end: function end() {\n        _end(this);\n      },\n      write: write,\n      resume: function resume() {\n        this.error = null;\n        return this;\n      },\n      close: function close() {\n        return this.write(null);\n      }\n    };\n\n    try {\n      Stream = fakeStream.Stream;\n    } catch (ex) {\n      Stream = function Stream() {};\n    }\n\n    function createStream(opt) {\n      return new CStream(opt);\n    }\n\n    function CStream(opt) {\n      if (!(this instanceof CStream)) return new CStream(opt);\n      this._parser = new CParser(opt);\n      this.writable = true;\n      this.readable = true; //var Buffer = this.Buffer || function Buffer () {}; // if we don't have Buffers, fake it so we can do `var instanceof Buffer` and not throw an error\n\n      this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n\n      this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n\n      this.temp_buffs = {\n        \"2\": new Buffer(2),\n        \"3\": new Buffer(3),\n        \"4\": new Buffer(4)\n      }; // for rebuilding chars split before boundary is reached\n\n      this.string = '';\n      var me = this;\n      Stream.apply(me);\n\n      this._parser.onend = function () {\n        me.emit(\"end\");\n      };\n\n      this._parser.onerror = function (er) {\n        me.emit(\"error\", er);\n        me._parser.error = null;\n      };\n\n      streamWraps.forEach(function (ev) {\n        Object.defineProperty(me, \"on\" + ev, {\n          get: function get() {\n            return me._parser[\"on\" + ev];\n          },\n          set: function set(h) {\n            if (!h) {\n              me.removeAllListeners(ev);\n              me._parser[\"on\" + ev] = h;\n              return h;\n            }\n\n            me.on(ev, h);\n          },\n          enumerable: true,\n          configurable: false\n        });\n      });\n    }\n\n    CStream.prototype = Object.create(Stream.prototype, {\n      constructor: {\n        value: CStream\n      }\n    });\n\n    CStream.prototype.write = function (data) {\n      data = new Buffer(data);\n\n      for (var i = 0; i < data.length; i++) {\n        var n = data[i]; // check for carry over of a multi byte char split between data chunks\n        // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n\n        if (this.bytes_remaining > 0) {\n          for (var j = 0; j < this.bytes_remaining; j++) {\n            this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];\n          }\n\n          this.string = this.temp_buffs[this.bytes_in_sequence].toString();\n          this.bytes_in_sequence = this.bytes_remaining = 0; // move iterator forward by number of byte read during sequencing\n\n          i = i + j - 1; // pass data to parser and move forward to parse rest of data\n\n          this._parser.write(this.string);\n\n          this.emit(\"data\", this.string);\n          continue;\n        } // if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n\n\n        if (this.bytes_remaining === 0 && n >= 128) {\n          if (n >= 194 && n <= 223) this.bytes_in_sequence = 2;\n          if (n >= 224 && n <= 239) this.bytes_in_sequence = 3;\n          if (n >= 240 && n <= 244) this.bytes_in_sequence = 4;\n\n          if (this.bytes_in_sequence + i > data.length) {\n            // if bytes needed to complete char fall outside data length, we have a boundary split\n            for (var k = 0; k <= data.length - 1 - i; k++) {\n              this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this chunk\n            }\n\n            this.bytes_remaining = i + this.bytes_in_sequence - data.length; // immediately return as we need another chunk to sequence the character\n\n            return true;\n          } else {\n            this.string = data.slice(i, i + this.bytes_in_sequence).toString();\n            i = i + this.bytes_in_sequence - 1;\n\n            this._parser.write(this.string);\n\n            this.emit(\"data\", this.string);\n            continue;\n          }\n        } // is there a range of characters that are immediately parsable?\n\n\n        for (var p = i; p < data.length; p++) {\n          if (data[p] >= 128) break;\n        }\n\n        this.string = data.slice(i, p).toString();\n\n        this._parser.write(this.string);\n\n        this.emit(\"data\", this.string);\n        i = p - 1; // handle any remaining characters using multibyte logic\n\n        continue;\n      }\n    };\n\n    CStream.prototype.end = function (chunk) {\n      if (chunk && chunk.length) this._parser.write(chunk.toString());\n\n      this._parser.end();\n\n      return true;\n    };\n\n    CStream.prototype.on = function (ev, handler) {\n      var me = this;\n\n      if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n        me._parser[\"on\" + ev] = function () {\n          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n          args.splice(0, 0, ev);\n          me.emit.apply(me, args);\n        };\n      }\n\n      return Stream.prototype.on.call(me, ev, handler);\n    };\n\n    CStream.prototype.destroy = function () {\n      clearBuffers(this._parser);\n      this.emit(\"close\");\n    };\n\n    function emit(parser, event, data) {\n      if (clarinet.INFO) console.log('-- emit', event, data);\n      if (parser[event]) parser[event](data);\n    }\n\n    function emitNode(parser, event, data) {\n      closeValue(parser);\n      emit(parser, event, data);\n    }\n\n    function closeValue(parser, event) {\n      parser.textNode = textopts(parser.opt, parser.textNode);\n\n      if (parser.textNode !== undefined) {\n        emit(parser, event ? event : \"onvalue\", parser.textNode);\n      }\n\n      parser.textNode = undefined;\n    }\n\n    function closeNumber(parser) {\n      if (parser.numberNode) emit(parser, \"onvalue\", parseFloat(parser.numberNode));\n      parser.numberNode = \"\";\n    }\n\n    function textopts(opt, text) {\n      if (text === undefined) {\n        return text;\n      }\n\n      if (opt.trim) text = text.trim();\n      if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n      return text;\n    }\n\n    function error(parser, er) {\n      closeValue(parser);\n      er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n      er = new Error(er);\n      parser.error = er;\n      emit(parser, \"onerror\", er);\n      return parser;\n    }\n\n    function _end(parser) {\n      if (parser.state !== S.VALUE || parser.depth !== 0) error(parser, \"Unexpected end\");\n      closeValue(parser);\n      parser.c = \"\";\n      parser.closed = true;\n      emit(parser, \"onend\");\n      CParser.call(parser, parser.opt);\n      return parser;\n    }\n\n    function isWhitespace(c) {\n      return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;\n    }\n\n    function write(chunk) {\n      var parser = this;\n      if (this.error) throw this.error;\n      if (parser.closed) return error(parser, \"Cannot write after close. Assign an onready handler.\");\n      if (chunk === null) return _end(parser);\n      var i = 0,\n          c = chunk.charCodeAt(0),\n          p = parser.p;\n      if (clarinet.DEBUG) console.log('write -> [' + chunk + ']');\n\n      while (c) {\n        p = c;\n        parser.c = c = chunk.charCodeAt(i++); // if chunk doesnt have next, like streaming char by char\n        // this way we need to check if previous is really previous\n        // if not we need to reset to what the parser says is the previous\n        // from buffer\n\n        if (p !== c) parser.p = p;else p = parser.p;\n        if (!c) break;\n        if (clarinet.DEBUG) console.log(i, c, clarinet.STATE[parser.state]);\n        parser.position++;\n\n        if (c === Char.lineFeed) {\n          parser.line++;\n          parser.column = 0;\n        } else parser.column++;\n\n        switch (parser.state) {\n          case S.BEGIN:\n            if (c === Char.openBrace) parser.state = S.OPEN_OBJECT;else if (c === Char.openBracket) parser.state = S.OPEN_ARRAY;else if (!isWhitespace(c)) error(parser, \"Non-whitespace before {[.\");\n            continue;\n\n          case S.OPEN_KEY:\n          case S.OPEN_OBJECT:\n            if (isWhitespace(c)) continue;\n            if (parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);else {\n              if (c === Char.closeBrace) {\n                emit(parser, 'onopenobject');\n                this.depth++;\n                emit(parser, 'oncloseobject');\n                this.depth--;\n                parser.state = parser.stack.pop() || S.VALUE;\n                continue;\n              } else parser.stack.push(S.CLOSE_OBJECT);\n            }\n            if (c === Char.doubleQuote) parser.state = S.STRING;else error(parser, \"Malformed object key should start with \\\"\");\n            continue;\n\n          case S.CLOSE_KEY:\n          case S.CLOSE_OBJECT:\n            if (isWhitespace(c)) continue;\n            var event = parser.state === S.CLOSE_KEY ? 'key' : 'object';\n\n            if (c === Char.colon) {\n              if (parser.state === S.CLOSE_OBJECT) {\n                parser.stack.push(S.CLOSE_OBJECT);\n                closeValue(parser, 'onopenobject');\n                this.depth++;\n              } else closeValue(parser, 'onkey');\n\n              parser.state = S.VALUE;\n            } else if (c === Char.closeBrace) {\n              emitNode(parser, 'oncloseobject');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n            } else if (c === Char.comma) {\n              if (parser.state === S.CLOSE_OBJECT) parser.stack.push(S.CLOSE_OBJECT);\n              closeValue(parser);\n              parser.state = S.OPEN_KEY;\n            } else error(parser, 'Bad object');\n\n            continue;\n\n          case S.OPEN_ARRAY: // after an array there always a value\n\n          case S.VALUE:\n            if (isWhitespace(c)) continue;\n\n            if (parser.state === S.OPEN_ARRAY) {\n              emit(parser, 'onopenarray');\n              this.depth++;\n              parser.state = S.VALUE;\n\n              if (c === Char.closeBracket) {\n                emit(parser, 'onclosearray');\n                this.depth--;\n                parser.state = parser.stack.pop() || S.VALUE;\n                continue;\n              } else {\n                parser.stack.push(S.CLOSE_ARRAY);\n              }\n            }\n\n            if (c === Char.doubleQuote) parser.state = S.STRING;else if (c === Char.openBrace) parser.state = S.OPEN_OBJECT;else if (c === Char.openBracket) parser.state = S.OPEN_ARRAY;else if (c === Char.t) parser.state = S.TRUE;else if (c === Char.f) parser.state = S.FALSE;else if (c === Char.n) parser.state = S.NULL;else if (c === Char.minus) {\n              // keep and continue\n              parser.numberNode += \"-\";\n            } else if (Char._0 <= c && c <= Char._9) {\n              parser.numberNode += String.fromCharCode(c);\n              parser.state = S.NUMBER_DIGIT;\n            } else error(parser, \"Bad value\");\n            continue;\n\n          case S.CLOSE_ARRAY:\n            if (c === Char.comma) {\n              parser.stack.push(S.CLOSE_ARRAY);\n              closeValue(parser, 'onvalue');\n              parser.state = S.VALUE;\n            } else if (c === Char.closeBracket) {\n              emitNode(parser, 'onclosearray');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n            } else if (isWhitespace(c)) continue;else error(parser, 'Bad array');\n\n            continue;\n\n          case S.STRING:\n            if (parser.textNode === undefined) {\n              parser.textNode = \"\";\n            } // thanks thejh, this is an about 50% performance improvement.\n\n\n            var starti = i - 1,\n                slashed = parser.slashed,\n                unicodeI = parser.unicodeI;\n\n            STRING_BIGLOOP: while (true) {\n              if (clarinet.DEBUG) console.log(i, c, clarinet.STATE[parser.state], slashed); // zero means \"no unicode active\". 1-4 mean \"parse some more\". end after 4.\n\n              while (unicodeI > 0) {\n                parser.unicodeS += String.fromCharCode(c);\n                c = chunk.charCodeAt(i++);\n                parser.position++;\n\n                if (unicodeI === 4) {\n                  // TODO this might be slow? well, probably not used too often anyway\n                  parser.textNode += String.fromCharCode(parseInt(parser.unicodeS, 16));\n                  unicodeI = 0;\n                  starti = i - 1;\n                } else {\n                  unicodeI++;\n                } // we can just break here: no stuff we skipped that still has to be sliced out or so\n\n\n                if (!c) break STRING_BIGLOOP;\n              }\n\n              if (c === Char.doubleQuote && !slashed) {\n                parser.state = parser.stack.pop() || S.VALUE;\n                parser.textNode += chunk.substring(starti, i - 1);\n                parser.position += i - 1 - starti;\n                break;\n              }\n\n              if (c === Char.backslash && !slashed) {\n                slashed = true;\n                parser.textNode += chunk.substring(starti, i - 1);\n                parser.position += i - 1 - starti;\n                c = chunk.charCodeAt(i++);\n                parser.position++;\n                if (!c) break;\n              }\n\n              if (slashed) {\n                slashed = false;\n\n                if (c === Char.n) {\n                  parser.textNode += '\\n';\n                } else if (c === Char.r) {\n                  parser.textNode += '\\r';\n                } else if (c === Char.t) {\n                  parser.textNode += '\\t';\n                } else if (c === Char.f) {\n                  parser.textNode += '\\f';\n                } else if (c === Char.b) {\n                  parser.textNode += '\\b';\n                } else if (c === Char.u) {\n                  // \\uxxxx. meh!\n                  unicodeI = 1;\n                  parser.unicodeS = '';\n                } else {\n                  parser.textNode += String.fromCharCode(c);\n                }\n\n                c = chunk.charCodeAt(i++);\n                parser.position++;\n                starti = i - 1;\n                if (!c) break;else continue;\n              }\n\n              stringTokenPattern.lastIndex = i;\n              var reResult = stringTokenPattern.exec(chunk);\n\n              if (reResult === null) {\n                i = chunk.length + 1;\n                parser.textNode += chunk.substring(starti, i - 1);\n                parser.position += i - 1 - starti;\n                break;\n              }\n\n              i = reResult.index + 1;\n              c = chunk.charCodeAt(reResult.index);\n\n              if (!c) {\n                parser.textNode += chunk.substring(starti, i - 1);\n                parser.position += i - 1 - starti;\n                break;\n              }\n            }\n\n            parser.slashed = slashed;\n            parser.unicodeI = unicodeI;\n            continue;\n\n          case S.TRUE:\n            if (c === Char.r) parser.state = S.TRUE2;else error(parser, 'Invalid true started with t' + c);\n            continue;\n\n          case S.TRUE2:\n            if (c === Char.u) parser.state = S.TRUE3;else error(parser, 'Invalid true started with tr' + c);\n            continue;\n\n          case S.TRUE3:\n            if (c === Char.e) {\n              emit(parser, \"onvalue\", true);\n              parser.state = parser.stack.pop() || S.VALUE;\n            } else error(parser, 'Invalid true started with tru' + c);\n\n            continue;\n\n          case S.FALSE:\n            if (c === Char.a) parser.state = S.FALSE2;else error(parser, 'Invalid false started with f' + c);\n            continue;\n\n          case S.FALSE2:\n            if (c === Char.l) parser.state = S.FALSE3;else error(parser, 'Invalid false started with fa' + c);\n            continue;\n\n          case S.FALSE3:\n            if (c === Char.s) parser.state = S.FALSE4;else error(parser, 'Invalid false started with fal' + c);\n            continue;\n\n          case S.FALSE4:\n            if (c === Char.e) {\n              emit(parser, \"onvalue\", false);\n              parser.state = parser.stack.pop() || S.VALUE;\n            } else error(parser, 'Invalid false started with fals' + c);\n\n            continue;\n\n          case S.NULL:\n            if (c === Char.u) parser.state = S.NULL2;else error(parser, 'Invalid null started with n' + c);\n            continue;\n\n          case S.NULL2:\n            if (c === Char.l) parser.state = S.NULL3;else error(parser, 'Invalid null started with nu' + c);\n            continue;\n\n          case S.NULL3:\n            if (c === Char.l) {\n              emit(parser, \"onvalue\", null);\n              parser.state = parser.stack.pop() || S.VALUE;\n            } else error(parser, 'Invalid null started with nul' + c);\n\n            continue;\n\n          case S.NUMBER_DECIMAL_POINT:\n            if (c === Char.period) {\n              parser.numberNode += \".\";\n              parser.state = S.NUMBER_DIGIT;\n            } else error(parser, 'Leading zero not followed by .');\n\n            continue;\n\n          case S.NUMBER_DIGIT:\n            if (Char._0 <= c && c <= Char._9) parser.numberNode += String.fromCharCode(c);else if (c === Char.period) {\n              if (parser.numberNode.indexOf('.') !== -1) error(parser, 'Invalid number has two dots');\n              parser.numberNode += \".\";\n            } else if (c === Char.e || c === Char.E) {\n              if (parser.numberNode.indexOf('e') !== -1 || parser.numberNode.indexOf('E') !== -1) error(parser, 'Invalid number has two exponential');\n              parser.numberNode += \"e\";\n            } else if (c === Char.plus || c === Char.minus) {\n              if (!(p === Char.e || p === Char.E)) error(parser, 'Invalid symbol in number');\n              parser.numberNode += String.fromCharCode(c);\n            } else {\n              closeNumber(parser);\n              i--; // go back one\n\n              parser.state = parser.stack.pop() || S.VALUE;\n            }\n            continue;\n\n          default:\n            error(parser, \"Unknown state: \" + parser.state);\n        }\n      }\n\n      if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);\n      return parser;\n    }\n  })(exports);\n});\n\nfunction JsonStream(blob) {\n  var pos = 0;\n  var parser = JsonParser(true);\n  var rv = {\n    pullAsync: function pullAsync(numBytes) {\n      return __awaiter(this, void 0, void 0, function () {\n        var slize, jsonPart, result;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              slize = blob.slice(pos, pos + numBytes);\n              pos += numBytes;\n              return [4\n              /*yield*/\n              , readBlobAsync(slize, 'text')];\n\n            case 1:\n              jsonPart = _a.sent();\n              result = parser.write(jsonPart);\n              rv.result = result || {};\n              return [2\n              /*return*/\n              , result];\n          }\n        });\n      });\n    },\n    pullSync: function pullSync(numBytes) {\n      var slize = blob.slice(pos, pos + numBytes);\n      pos += numBytes;\n      var jsonPart = readBlobSync(slize, 'text');\n      var result = parser.write(jsonPart);\n      rv.result = result || {};\n      return result;\n    },\n    done: function done() {\n      return parser.done();\n    },\n    eof: function eof() {\n      return pos >= blob.size;\n    },\n    result: {}\n  };\n  return rv;\n}\n\nfunction JsonParser(allowPartial) {\n  var parser = clarinet_1.parser();\n  var level = 0;\n  var result;\n  var stack = [];\n  var obj;\n  var key;\n  var _done = false;\n  var array = false;\n\n  parser.onopenobject = function (newKey) {\n    var newObj = {};\n    newObj.incomplete = true;\n    if (!result) result = newObj;\n\n    if (obj) {\n      stack.push([key, obj, array]);\n\n      if (allowPartial) {\n        if (array) {\n          obj.push(newObj);\n        } else {\n          obj[key] = newObj;\n        }\n      }\n    }\n\n    obj = newObj;\n    key = newKey;\n    array = false;\n    ++level;\n  };\n\n  parser.onkey = function (newKey) {\n    return key = newKey;\n  };\n\n  parser.onvalue = function (value) {\n    return array ? obj.push(value) : obj[key] = value;\n  };\n\n  parser.oncloseobject = function () {\n    var _a;\n\n    delete obj.incomplete;\n    key = null;\n\n    if (--level === 0) {\n      _done = true;\n    } else {\n      var completedObj = obj;\n      _a = stack.pop(), key = _a[0], obj = _a[1], array = _a[2];\n\n      if (!allowPartial) {\n        if (array) {\n          obj.push(completedObj);\n        } else {\n          obj[key] = completedObj;\n        }\n      }\n    }\n  };\n\n  parser.onopenarray = function () {\n    var newObj = [];\n    newObj.incomplete = true;\n    if (!result) result = newObj;\n\n    if (obj) {\n      stack.push([key, obj, array]);\n\n      if (allowPartial) {\n        if (array) {\n          obj.push(newObj);\n        } else {\n          obj[key] = newObj;\n        }\n      }\n    }\n\n    obj = newObj;\n    array = true;\n    key = null;\n    ++level;\n  };\n\n  parser.onclosearray = function () {\n    var _a;\n\n    delete obj.incomplete;\n    key = null;\n\n    if (--level === 0) {\n      _done = true;\n    } else {\n      var completedObj = obj;\n      _a = stack.pop(), key = _a[0], obj = _a[1], array = _a[2];\n\n      if (!allowPartial) {\n        if (array) {\n          obj.push(completedObj);\n        } else {\n          obj[key] = completedObj;\n        }\n      }\n    }\n  };\n\n  return {\n    write: function write(jsonPart) {\n      parser.write(jsonPart);\n      return result;\n    },\n    done: function done() {\n      return _done;\n    }\n  };\n}\n\nvar DEFAULT_KILOBYTES_PER_CHUNK = 1024;\n\nfunction importDB(exportedData, options) {\n  return __awaiter(this, void 0, void 0, function () {\n    var CHUNK_SIZE, stream, dbExport, db;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          options = options || {}; // All booleans defaults to false.\n\n          CHUNK_SIZE = options.chunkSizeBytes || DEFAULT_KILOBYTES_PER_CHUNK * 1024;\n          return [4\n          /*yield*/\n          , loadUntilWeGotEnoughData(exportedData, CHUNK_SIZE)];\n\n        case 1:\n          stream = _a.sent();\n          dbExport = stream.result.data;\n          db = new Dexie(dbExport.databaseName);\n          db.version(dbExport.databaseVersion).stores(extractDbSchema(dbExport));\n          return [4\n          /*yield*/\n          , importInto(db, stream, options)];\n\n        case 2:\n          _a.sent();\n\n          return [2\n          /*return*/\n          , db];\n      }\n    });\n  });\n}\n\nfunction importInto(db, exportedData, options) {\n  return __awaiter(this, void 0, void 0, function () {\n    function importAll() {\n      return __awaiter(this, void 0, void 0, function () {\n        var _loop_1, _i, _a, tableExport, state_1;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _loop_1 = function _loop_1(tableExport) {\n                var tableName, table, tableSchemaStr, sourceRows, rows, i, obj, filter, filteredRows, _a, keys, values;\n\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      if (!tableExport.rows) return [2\n                      /*return*/\n                      , \"break\"]; // Need to pull more!\n\n                      if (!tableExport.rows.incomplete && tableExport.rows.length === 0) return [2\n                      /*return*/\n                      , \"continue\"];\n\n                      if (progressCallback) {\n                        // Keep ongoing transaction private\n                        Dexie.ignoreTransaction(function () {\n                          return progressCallback(progress);\n                        });\n                      }\n\n                      tableName = tableExport.tableName;\n                      table = db.table(tableName);\n                      tableSchemaStr = dbExport.tables.filter(function (t) {\n                        return t.name === tableName;\n                      })[0].schema;\n\n                      if (!table) {\n                        if (!options.acceptMissingTables) throw new Error(\"Exported table \" + tableExport.tableName + \" is missing in installed database\");else return [2\n                        /*return*/\n                        , \"continue\"];\n                      }\n\n                      if (!options.acceptChangedPrimaryKey && tableSchemaStr.split(',')[0] != table.schema.primKey.src) {\n                        throw new Error(\"Primary key differs for table \" + tableExport.tableName + \". \");\n                      }\n\n                      sourceRows = tableExport.rows;\n                      rows = [];\n\n                      for (i = 0; i < sourceRows.length; i++) {\n                        obj = sourceRows[i];\n\n                        if (!obj.incomplete) {\n                          rows.push(TSON.revive(obj));\n                        } else {\n                          break;\n                        }\n                      }\n\n                      filter = options.filter;\n                      filteredRows = filter ? tableExport.inbound ? rows.filter(function (value) {\n                        return filter(tableName, value);\n                      }) : rows.filter(function (_a) {\n                        var key = _a[0],\n                            value = _a[1];\n                        return filter(tableName, value, key);\n                      }) : rows;\n                      _a = tableExport.inbound ? [undefined, filteredRows] : [filteredRows.map(function (row) {\n                        return row[0];\n                      }), rows.map(function (row) {\n                        return row[1];\n                      })], keys = _a[0], values = _a[1];\n                      if (!options.clearTablesBeforeImport) return [3\n                      /*break*/\n                      , 2];\n                      return [4\n                      /*yield*/\n                      , table.clear()];\n\n                    case 1:\n                      _b.sent();\n\n                      _b.label = 2;\n\n                    case 2:\n                      if (!options.overwriteValues) return [3\n                      /*break*/\n                      , 4];\n                      return [4\n                      /*yield*/\n                      , table.bulkPut(values, keys)];\n\n                    case 3:\n                      _b.sent();\n\n                      return [3\n                      /*break*/\n                      , 6];\n\n                    case 4:\n                      return [4\n                      /*yield*/\n                      , table.bulkAdd(values, keys)];\n\n                    case 5:\n                      _b.sent();\n\n                      _b.label = 6;\n\n                    case 6:\n                      progress.completedRows += rows.length;\n\n                      if (!rows.incomplete) {\n                        progress.completedTables += 1;\n                      }\n\n                      sourceRows.splice(0, rows.length); // Free up RAM, keep existing array instance.\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              };\n\n              _i = 0, _a = dbExport.data;\n              _b.label = 1;\n\n            case 1:\n              if (!(_i < _a.length)) return [3\n              /*break*/\n              , 4];\n              tableExport = _a[_i];\n              return [5\n              /*yield**/\n              , _loop_1(tableExport)];\n\n            case 2:\n              state_1 = _b.sent();\n              if (state_1 === \"break\") return [3\n              /*break*/\n              , 4];\n              _b.label = 3;\n\n            case 3:\n              _i++;\n              return [3\n              /*break*/\n              , 1];\n\n            case 4:\n              // Avoid unnescessary loops in \"for (const tableExport of dbExport.data)\" \n              while (dbExport.data.length > 0 && dbExport.data[0].rows && !dbExport.data[0].rows.incomplete) {\n                // We've already imported all rows from the first table. Delete its occurrence\n                dbExport.data.splice(0, 1);\n              }\n\n              if (!(!jsonStream.done() && !jsonStream.eof())) return [3\n              /*break*/\n              , 8];\n              if (!readBlobsSynchronously) return [3\n              /*break*/\n              , 5]; // If we can pull from blob synchronically, we don't have to\n              // keep transaction alive using Dexie.waitFor().\n              // This will only be possible in workers.\n\n              jsonStream.pullSync(CHUNK_SIZE);\n              return [3\n              /*break*/\n              , 7];\n\n            case 5:\n              return [4\n              /*yield*/\n              , Dexie.waitFor(jsonStream.pullAsync(CHUNK_SIZE))];\n\n            case 6:\n              _b.sent();\n\n              _b.label = 7;\n\n            case 7:\n              return [3\n              /*break*/\n              , 9];\n\n            case 8:\n              return [3\n              /*break*/\n              , 10];\n\n            case 9:\n              return [3\n              /*break*/\n              , 0];\n              _b.label = 10;\n\n            case 10:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n\n    var CHUNK_SIZE, jsonStream, dbExportFile, readBlobsSynchronously, dbExport, progressCallback, progress;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          options = options || {}; // All booleans defaults to false.\n\n          CHUNK_SIZE = options.chunkSizeBytes || DEFAULT_KILOBYTES_PER_CHUNK * 1024;\n          return [4\n          /*yield*/\n          , loadUntilWeGotEnoughData(exportedData, CHUNK_SIZE)];\n\n        case 1:\n          jsonStream = _a.sent();\n          dbExportFile = jsonStream.result;\n          readBlobsSynchronously = 'FileReaderSync' in self;\n          dbExport = dbExportFile.data;\n          if (!options.acceptNameDiff && db.name !== dbExport.databaseName) throw new Error(\"Name differs. Current database name is \" + db.name + \" but export is \" + dbExport.databaseName);\n\n          if (!options.acceptVersionDiff && db.verno !== dbExport.databaseVersion) {\n            // Possible feature: Call upgraders in some isolated way if this happens... ?\n            throw new Error(\"Database version differs. Current database is in version \" + db.verno + \" but export is \" + dbExport.databaseVersion);\n          }\n\n          progressCallback = options.progressCallback;\n          progress = {\n            done: false,\n            completedRows: 0,\n            completedTables: 0,\n            totalRows: dbExport.tables.reduce(function (p, c) {\n              return p + c.rowCount;\n            }, 0),\n            totalTables: dbExport.tables.length\n          };\n\n          if (progressCallback) {\n            // Keep ongoing transaction private\n            Dexie.ignoreTransaction(function () {\n              return progressCallback(progress);\n            });\n          }\n\n          if (!options.noTransaction) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , importAll()];\n\n        case 2:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 5];\n\n        case 3:\n          return [4\n          /*yield*/\n          , db.transaction('rw', db.tables, importAll)];\n\n        case 4:\n          _a.sent();\n\n          _a.label = 5;\n\n        case 5:\n          progress.done = true;\n\n          if (progressCallback) {\n            // Keep ongoing transaction private\n            Dexie.ignoreTransaction(function () {\n              return progressCallback(progress);\n            });\n          }\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction loadUntilWeGotEnoughData(exportedData, CHUNK_SIZE) {\n  return __awaiter(this, void 0, void 0, function () {\n    var stream, dbExportFile;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          stream = 'slice' in exportedData ? JsonStream(exportedData) : exportedData;\n          _a.label = 1;\n\n        case 1:\n          if (!!stream.eof()) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , stream.pullAsync(CHUNK_SIZE)];\n\n        case 2:\n          _a.sent();\n\n          if (stream.result.data && stream.result.data.data) return [3\n          /*break*/\n          , 3];\n          return [3\n          /*break*/\n          , 1];\n\n        case 3:\n          dbExportFile = stream.result;\n          if (!dbExportFile || dbExportFile.formatName != \"dexie\") throw new Error(\"Given file is not a dexie export\");\n\n          if (dbExportFile.formatVersion > VERSION) {\n            throw new Error(\"Format version \" + dbExportFile.formatVersion + \" not supported\");\n          }\n\n          if (!dbExportFile.data) {\n            throw new Error(\"No data in export file\");\n          }\n\n          if (!dbExportFile.data.databaseName) {\n            throw new Error(\"Missing databaseName in export file\");\n          }\n\n          if (!dbExportFile.data.databaseVersion) {\n            throw new Error(\"Missing databaseVersion in export file\");\n          }\n\n          if (!dbExportFile.data.tables) {\n            throw new Error(\"Missing tables in export file\");\n          }\n\n          return [2\n          /*return*/\n          , stream];\n      }\n    });\n  });\n} //\n// Extend Dexie interface (runtime wise)\n//\n\n\nDexie.prototype.export = function (options) {\n  return exportDB(this, options);\n};\n\nDexie.prototype.import = function (blob, options) {\n  return importInto(this, blob, options);\n};\n\nDexie.import = function (blob, options) {\n  return importDB(blob, options);\n};\n\nvar dexieExportImport = function dexieExportImport() {\n  throw new Error(\"This addon extends Dexie.prototype globally and does not have be included in Dexie constructor's addons options.\");\n};\n\nexport default dexieExportImport;\nexport { exportDB, importDB, importInto };","map":null,"metadata":{},"sourceType":"module"}