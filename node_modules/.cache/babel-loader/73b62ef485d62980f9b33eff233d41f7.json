{"ast":null,"code":"/* ========================================================================== \n *                           dexie-observable.js\n * ==========================================================================\n *\n * Dexie addon for observing database changes not just on local db instance\n * but also on other instances, tabs and windows.\n *\n * Comprises a base framework for dexie-syncable.js\n *\n * By David Fahlander, david.fahlander@gmail.com,\n *    Nikolas Poniros, https://github.com/nponiros\n *\n * ==========================================================================\n *\n * Version {version}, {date}\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n * \n */\nimport Dexie from 'dexie';\n\nfunction nop() {}\n\nfunction promisableChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n\n    if (res && typeof res.then === 'function') {\n      var thiz = this,\n          args = arguments;\n      return res.then(function () {\n        return f2.apply(thiz, args);\n      });\n    }\n\n    return f2.apply(this, arguments);\n  };\n}\n\nfunction createUUID() {\n  // Decent solution from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n  var d = Date.now();\n  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);\n  });\n  return uuid;\n}\n\nfunction initOverrideCreateTransaction(db, wakeupObservers) {\n  return function overrideCreateTransaction(origFunc) {\n    return function (mode, storenames, dbschema, parent) {\n      if (db.dynamicallyOpened()) return origFunc.apply(this, arguments); // Don't observe dynamically opened databases.\n\n      var addChanges = false;\n\n      if (mode === 'readwrite' && storenames.some(function (storeName) {\n        return dbschema[storeName] && dbschema[storeName].observable;\n      })) {\n        // At least one included store is a observable store. Make sure to also include the _changes store.\n        addChanges = true;\n        storenames = storenames.slice(0); // Clone\n\n        if (storenames.indexOf(\"_changes\") === -1) storenames.push(\"_changes\"); // Otherwise, firefox will hang... (I've reported the bug to Mozilla@Bugzilla)\n      } // Call original db._createTransaction()\n\n\n      var trans = origFunc.call(this, mode, storenames, dbschema, parent); // If this transaction is bound to any observable table, make sure to add changes when transaction completes.\n\n      if (addChanges) {\n        trans._lastWrittenRevision = 0;\n        trans.on('complete', function () {\n          if (trans._lastWrittenRevision) {\n            // Changes were written in this transaction.\n            if (!parent) {\n              // This is root-level transaction, i.e. a physical commit has happened.\n              // Delay-trigger a wakeup call:\n              if (wakeupObservers.timeoutHandle) clearTimeout(wakeupObservers.timeoutHandle);\n              wakeupObservers.timeoutHandle = setTimeout(function () {\n                delete wakeupObservers.timeoutHandle;\n                wakeupObservers(trans._lastWrittenRevision);\n              }, 25);\n            } else {\n              // This is just a virtual commit of a sub transaction.\n              // Wait with waking up observers until root transaction has committed.\n              // Make sure to mark root transaction so that it will wakeup observers upon commit.\n              var rootTransaction = function findRootTransaction(trans) {\n                return trans.parent ? findRootTransaction(trans.parent) : trans;\n              }(parent);\n\n              rootTransaction._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rootTransaction.lastWrittenRevision || 0);\n            }\n          }\n        }); // Derive \"source\" property from parent transaction by default\n\n        if (trans.parent && trans.parent.source) trans.source = trans.parent.source;\n      }\n\n      return trans;\n    };\n  };\n}\n\nfunction initWakeupObservers(db, Observable, localStorage) {\n  return function wakeupObservers(lastWrittenRevision) {\n    // Make sure Observable.latestRevision[db.name] is still below our value, now when some time has elapsed and other db instances in same window possibly could have made changes too.\n    if (Observable.latestRevision[db.name] < lastWrittenRevision) {\n      // Set the static property lastRevision[db.name] to the revision of the last written change.\n      Observable.latestRevision[db.name] = lastWrittenRevision; // Wakeup ourselves, and any other db instances on this window:\n\n      Dexie.ignoreTransaction(function () {\n        Observable.on('latestRevisionIncremented').fire(db.name, lastWrittenRevision);\n      }); // Observable.on.latestRevisionIncremented will only wakeup db's in current window.\n      // We need a storage event to wakeup other windwos.\n      // Since indexedDB lacks storage events, let's use the storage event from WebStorage just for\n      // the purpose to wakeup db instances in other windows.\n\n      if (localStorage) localStorage.setItem('Dexie.Observable/latestRevision/' + db.name, lastWrittenRevision); // In IE, this will also wakeup our own window. However, onLatestRevisionIncremented will work around this by only running once per revision id.\n    }\n  };\n} // Change Types\n\n\nvar CREATE = 1;\nvar UPDATE = 2;\nvar DELETE = 3;\n\nfunction initCreatingHook(db, table) {\n  return function creatingHook(primKey, obj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    var rv = undefined;\n\n    if (primKey === undefined && table.schema.primKey.uuid) {\n      primKey = rv = createUUID();\n\n      if (table.schema.primKey.keyPath) {\n        Dexie.setByKeyPath(obj, table.schema.primKey.keyPath, primKey);\n      }\n    }\n\n    var change = {\n      source: trans.source || null,\n      table: table.name,\n      key: primKey === undefined ? null : primKey,\n      type: CREATE,\n      obj: obj\n    };\n\n    var promise = db._changes.add(change).then(function (rev) {\n      trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n      return rev;\n    }); // Wait for onsuccess so that we have the primKey if it is auto-incremented and update the change item if so.\n\n\n    this.onsuccess = function (resultKey) {\n      if (primKey != resultKey) promise._then(function () {\n        change.key = resultKey;\n\n        db._changes.put(change);\n      });\n    };\n\n    this.onerror = function () {\n      // If the main operation fails, make sure to regret the change\n      promise._then(function (rev) {\n        // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n        db._changes.delete(rev);\n      });\n    };\n\n    return rv;\n  };\n}\n\nfunction initUpdatingHook(db, tableName) {\n  return function updatingHook(mods, primKey, oldObj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    // mods may contain property paths with undefined as value if the property\n    // is being deleted. Since we cannot persist undefined we need to act\n    // like those changes is setting the value to null instead.\n    var modsWithoutUndefined = {}; // As of current Dexie version (1.0.3) hook may be called even if it wouldn't really change.\n    // Therefore we may do that kind of optimization here - to not add change entries if\n    // there's nothing to change.\n\n    var anythingChanged = false;\n    var newObj = Dexie.deepClone(oldObj);\n\n    for (var propPath in mods) {\n      var mod = mods[propPath];\n\n      if (typeof mod === 'undefined') {\n        Dexie.delByKeyPath(newObj, propPath);\n        modsWithoutUndefined[propPath] = null; // Null is as close we could come to deleting a property when not allowing undefined.\n\n        anythingChanged = true;\n      } else {\n        var currentValue = Dexie.getByKeyPath(oldObj, propPath);\n\n        if (mod !== currentValue && JSON.stringify(mod) !== JSON.stringify(currentValue)) {\n          Dexie.setByKeyPath(newObj, propPath, mod);\n          modsWithoutUndefined[propPath] = mod;\n          anythingChanged = true;\n        }\n      }\n    }\n\n    if (anythingChanged) {\n      var change = {\n        source: trans.source || null,\n        table: tableName,\n        key: primKey,\n        type: UPDATE,\n        mods: modsWithoutUndefined,\n        oldObj: oldObj,\n        obj: newObj\n      };\n\n      var promise = db._changes.add(change); // Just so we get the correct revision order of the update...\n\n\n      this.onsuccess = function () {\n        promise._then(function (rev) {\n          trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n        });\n      };\n\n      this.onerror = function () {\n        // If the main operation fails, make sure to regret the change.\n        promise._then(function (rev) {\n          // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n          db._changes.delete(rev);\n        });\n      };\n    }\n  };\n}\n\nfunction initDeletingHook(db, tableName) {\n  return function deletingHook(primKey, obj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    var promise = db._changes.add({\n      source: trans.source || null,\n      table: tableName,\n      key: primKey,\n      type: DELETE,\n      oldObj: obj\n    }).then(function (rev) {\n      trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n      return rev;\n    }).catch(function (e) {\n      console.log(obj);\n      console.log(e.stack);\n    });\n\n    this.onerror = function () {\n      // If the main operation fails, make sure to regret the change.\n      // Using _then because if promise is already fullfilled, the standard then() would\n      // do setTimeout() and we would loose the transaction.\n      promise._then(function (rev) {\n        // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n        db._changes.delete(rev);\n      });\n    };\n  };\n}\n\nfunction initCrudMonitor(db) {\n  //\n  // The Creating/Updating/Deleting hook will make sure any change is stored to the changes table\n  //\n  return function crudMonitor(table) {\n    /// <param name=\"table\" type=\"db.Table\"></param>\n    if (table.hook._observing) return;\n    table.hook._observing = true;\n    var tableName = table.name;\n    table.hook('creating').subscribe(initCreatingHook(db, table));\n    table.hook('updating').subscribe(initUpdatingHook(db, tableName));\n    table.hook('deleting').subscribe(initDeletingHook(db, tableName));\n  };\n}\n\nfunction initOnStorage(Observable) {\n  return function onStorage(event) {\n    // We use the onstorage event to trigger onLatestRevisionIncremented since we will wake up when other windows modify the DB as well!\n    if (event.key.indexOf(\"Dexie.Observable/\") === 0) {\n      // For example \"Dexie.Observable/latestRevision/FriendsDB\"\n      var parts = event.key.split('/');\n      var prop = parts[1];\n      var dbname = parts[2];\n\n      if (prop === 'latestRevision') {\n        var rev = parseInt(event.newValue, 10);\n\n        if (!isNaN(rev) && rev > Observable.latestRevision[dbname]) {\n          Observable.latestRevision[dbname] = rev;\n          Dexie.ignoreTransaction(function () {\n            Observable.on('latestRevisionIncremented').fire(dbname, rev);\n          });\n        }\n      } else if (prop.indexOf(\"deadnode:\") === 0) {\n        var nodeID = parseInt(prop.split(':')[1], 10);\n\n        if (event.newValue) {\n          Observable.on.suicideNurseCall.fire(dbname, nodeID);\n        }\n      } else if (prop === 'intercomm') {\n        if (event.newValue) {\n          Observable.on.intercomm.fire(dbname);\n        }\n      }\n    }\n  };\n}\n\nfunction initOverrideOpen(db, SyncNode, crudMonitor) {\n  return function overrideOpen(origOpen) {\n    return function () {\n      //\n      // Make sure to subscribe to \"creating\", \"updating\" and \"deleting\" hooks for all observable tables that were created in the stores() method.\n      //\n      Object.keys(db._allTables).forEach(function (tableName) {\n        var table = db._allTables[tableName];\n\n        if (table.schema.observable) {\n          crudMonitor(table);\n        }\n\n        if (table.name === \"_syncNodes\") {\n          table.mapToClass(SyncNode);\n        }\n      });\n      return origOpen.apply(this, arguments);\n    };\n  };\n}\n\nvar Promise = Dexie.Promise;\n\nfunction initIntercomm(db, Observable, SyncNode, mySyncNode, localStorage) {\n  //\n  // Intercommunication between nodes\n  //\n  // Enable inter-process communication between browser windows using localStorage storage event (is registered in Dexie.Observable)\n  var requestsWaitingForReply = {};\n  /**\n   * @param {string} type Type of message\n   * @param message Message to send\n   * @param {number} destinationNode ID of destination node\n   * @param {{wantReply: boolean, isFailure: boolean, requestId: number}} options If {wantReply: true}, the returned promise will complete with the reply from remote. Otherwise it will complete when message has been successfully sent.</param>\n   */\n\n  db.observable.sendMessage = function (type, message, destinationNode, options) {\n    /// <param name=\"type\" type=\"String\">Type of message</param>\n    /// <param name=\"message\">Message to send</param>\n    /// <param name=\"destinationNode\" type=\"Number\">ID of destination node</param>\n    /// <param name=\"options\" type=\"Object\" optional=\"true\">{wantReply: Boolean, isFailure: Boolean, requestId: Number}. If wantReply, the returned promise will complete with the reply from remote. Otherwise it will complete when message has been successfully sent.</param>\n    options = options || {};\n    if (!mySyncNode.node) return options.wantReply ? Promise.reject(new Dexie.DatabaseClosedError()) : Promise.resolve(); // If caller doesn't want a reply, it won't catch errors either.\n\n    var msg = {\n      message: message,\n      destinationNode: destinationNode,\n      sender: mySyncNode.node.id,\n      type: type\n    };\n    Dexie.extend(msg, options); // wantReply: wantReply, success: !isFailure, requestId: ...\n\n    return Dexie.ignoreTransaction(function () {\n      var tables = [\"_intercomm\"];\n      if (options.wantReply) tables.push(\"_syncNodes\"); // If caller wants a reply, include \"_syncNodes\" in transaction to check that there's a receiver there. Otherwise, new master will get it.\n\n      var promise = db.transaction('rw', tables, function () {\n        if (options.wantReply) {\n          // Check that there is a receiver there to take the request.\n          return db._syncNodes.where('id').equals(destinationNode).count(function (receiverAlive) {\n            if (receiverAlive) return db._intercomm.add(msg);else // If we couldn't find a node -> send to master\n              return db._syncNodes.where('isMaster').above(0).first(function (masterNode) {\n                msg.destinationNode = masterNode.id;\n                return db._intercomm.add(msg);\n              });\n          });\n        } else {\n          // If caller doesn't need a response, we don't have to make sure that it gets one.\n          return db._intercomm.add(msg);\n        }\n      }).then(function (messageId) {\n        var rv = null;\n\n        if (options.wantReply) {\n          rv = new Promise(function (resolve, reject) {\n            requestsWaitingForReply[messageId.toString()] = {\n              resolve: resolve,\n              reject: reject\n            };\n          });\n        }\n\n        if (localStorage) {\n          localStorage.setItem(\"Dexie.Observable/intercomm/\" + db.name, messageId.toString());\n        }\n\n        Observable.on.intercomm.fire(db.name);\n        return rv;\n      });\n\n      if (!options.wantReply) {\n        promise.catch(function () {});\n        return;\n      } else {\n        // Forward rejection to caller if it waits for reply.\n        return promise;\n      }\n    });\n  }; // Send a message to all local _syncNodes\n\n\n  db.observable.broadcastMessage = function (type, message, bIncludeSelf) {\n    if (!mySyncNode.node) return;\n    var mySyncNodeId = mySyncNode.node.id;\n    Dexie.ignoreTransaction(function () {\n      db._syncNodes.toArray(function (nodes) {\n        return Promise.all(nodes.filter(function (node) {\n          return node.type === 'local' && (bIncludeSelf || node.id !== mySyncNodeId);\n        }).map(function (node) {\n          return db.observable.sendMessage(type, message, node.id);\n        }));\n      }).catch(function () {});\n    });\n  };\n\n  function consumeIntercommMessages() {\n    // Check if we got messages:\n    if (!mySyncNode.node) return Promise.reject(new Dexie.DatabaseClosedError());\n    return Dexie.ignoreTransaction(function () {\n      return db.transaction('rw', '_intercomm', function () {\n        return db._intercomm.where({\n          destinationNode: mySyncNode.node.id\n        }).toArray(function (messages) {\n          messages.forEach(function (msg) {\n            return consumeMessage(msg);\n          });\n          return db._intercomm.where('id').anyOf(messages.map(function (msg) {\n            return msg.id;\n          })).delete();\n        });\n      });\n    });\n  }\n\n  function consumeMessage(msg) {\n    if (msg.type === 'response') {\n      // This is a response. Lookup pending request and fulfill its promise.\n      var request = requestsWaitingForReply[msg.requestId.toString()];\n\n      if (request) {\n        if (msg.isFailure) {\n          request.reject(msg.message.error);\n        } else {\n          request.resolve(msg.message.result);\n        }\n\n        delete requestsWaitingForReply[msg.requestId.toString()];\n      }\n    } else {\n      // This is a message or request. Fire the event and add an API for the subscriber to use if reply is requested\n      msg.resolve = function (result) {\n        db.observable.sendMessage('response', {\n          result: result\n        }, msg.sender, {\n          requestId: msg.id\n        });\n      };\n\n      msg.reject = function (error) {\n        db.observable.sendMessage('response', {\n          error: error.toString()\n        }, msg.sender, {\n          isFailure: true,\n          requestId: msg.id\n        });\n      };\n\n      db.on.message.fire(msg);\n    }\n  } // Listener for 'intercomm' events\n  // Gets fired when we get a 'storage' event from local storage or when sendMessage is called\n  // 'storage' is used to communicate between tabs (sendMessage changes the localStorage to trigger the event)\n  // sendMessage is used to communicate in the same tab and to trigger a storage event\n\n\n  function onIntercomm(dbname) {\n    // When storage event trigger us to check\n    if (dbname === db.name) {\n      consumeIntercommMessages().catch('DatabaseClosedError', function () {});\n    }\n  }\n\n  return {\n    onIntercomm: onIntercomm,\n    consumeIntercommMessages: consumeIntercommMessages\n  };\n}\n\nfunction overrideParseStoresSpec(origFunc) {\n  return function (stores, dbSchema) {\n    // Create the _changes and _syncNodes tables\n    stores[\"_changes\"] = \"++rev\";\n    stores[\"_syncNodes\"] = \"++id,myRevision,lastHeartBeat,&url,isMaster,type,status\";\n    stores[\"_intercomm\"] = \"++id,destinationNode\";\n    stores[\"_uncommittedChanges\"] = \"++id,node\"; // For remote syncing when server returns a partial result.\n    // Call default implementation. Will populate the dbSchema structures.\n\n    origFunc.call(this, stores, dbSchema); // Allow UUID primary keys using $$ prefix on primary key or indexes\n\n    Object.keys(dbSchema).forEach(function (tableName) {\n      var schema = dbSchema[tableName];\n\n      if (schema.primKey.name.indexOf('$$') === 0) {\n        schema.primKey.uuid = true;\n        schema.primKey.name = schema.primKey.name.substr(2);\n        schema.primKey.keyPath = schema.primKey.keyPath.substr(2);\n      }\n    }); // Now mark all observable tables\n\n    Object.keys(dbSchema).forEach(function (tableName) {\n      // Marked observable tables with \"observable\" in their TableSchema.\n      if (tableName.indexOf('_') !== 0 && tableName.indexOf('$') !== 0) {\n        dbSchema[tableName].observable = true;\n      }\n    });\n  };\n}\n\nfunction deleteOldChanges(db) {\n  // This is a background job and should never be done within\n  // a caller's transaction. Use Dexie.ignoreTransaction() to ensure that.\n  // We should not return the Promise but catch it ourselves instead.\n  // To prohibit starving the database we want to lock transactions as short as possible\n  // and since we're not in a hurry, we could do this job in chunks and reschedule a\n  // continuation every 500 ms.\n  var CHUNK_SIZE = 100;\n  Dexie.ignoreTransaction(function () {\n    return db._syncNodes.orderBy(\"myRevision\").first(function (oldestNode) {\n      return db._changes.where(\"rev\").below(oldestNode.myRevision).limit(CHUNK_SIZE).primaryKeys();\n    }).then(function (keysToDelete) {\n      if (keysToDelete.length === 0) return; // Done.\n\n      return db._changes.bulkDelete(keysToDelete).then(function () {\n        // If not done garbage collecting, reschedule a continuation of it until done.\n        if (keysToDelete.length === CHUNK_SIZE) {\n          // Limit reached. Changes are there are more job to do. Schedule again:\n          setTimeout(function () {\n            return db.isOpen() && deleteOldChanges(db);\n          }, 500);\n        }\n      });\n    });\n  }).catch(function () {// The operation is not crucial. A failure could almost only be due to that database has been closed.\n    // No need to log this.\n  });\n}\n/* ==========================================================================\n *                           dexie-observable.js\n * ==========================================================================\n *\n * Dexie addon for observing database changes not just on local db instance\n * but also on other instances, tabs and windows.\n *\n * Comprises a base framework for dexie-syncable.js\n *\n * By David Fahlander, david.fahlander@gmail.com,\n *    Nikolas Poniros, https://github.com/nponiros\n *\n * ==========================================================================\n *\n * Version {version}, {date}\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n *\n */\n\n\nvar global = self;\n/** class DatabaseChange\n    *\n    *  Object contained by the _changes table.\n    */\n\nvar DatabaseChange = Dexie.defineClass({\n  rev: Number,\n  source: String,\n  table: String,\n  key: Object,\n  type: Number,\n  obj: Object,\n  mods: Object,\n  oldObj: Object // DELETE: oldObj contains the object deleted. UPDATE: oldObj contains the old object before updates applied.\n\n}); // Import some usable helper functions\n\nvar override = Dexie.override;\nvar Promise$1 = Dexie.Promise;\nvar browserIsShuttingDown = false;\n\nfunction Observable(db) {\n  /// <summary>\n  ///   Extension to Dexie providing Syncronization capabilities to Dexie.\n  /// </summary>\n  /// <param name=\"db\" type=\"Dexie\"></param>\n  var NODE_TIMEOUT = 20000,\n      // 20 seconds before local db instances are timed out. This is so that old changes can be deleted when not needed and to garbage collect old _syncNodes objects.\n  HIBERNATE_GRACE_PERIOD = 20000,\n      // 20 seconds\n  // LOCAL_POLL: The time to wait before polling local db for changes and cleaning up old nodes. \n  // Polling for changes is a fallback only needed in certain circomstances (when the onstorage event doesnt reach all listeners - when different browser windows doesnt share the same process)\n  LOCAL_POLL = 500,\n      // 500 ms. In real-world there will be this value + the time it takes to poll(). A small value is needed in Workers where we cannot rely on storage event.\n  HEARTBEAT_INTERVAL = NODE_TIMEOUT - 5000;\n  var localStorage = Observable.localStorageImpl;\n  /** class SyncNode\n      *\n      * Object contained in the _syncNodes table.\n      */\n\n  var SyncNode = Dexie.defineClass({\n    //id: Number,\n    myRevision: Number,\n    type: String,\n    lastHeartBeat: Number,\n    deleteTimeStamp: Number,\n    url: String,\n    isMaster: Number,\n    // Below properties should be extended in Dexie.Syncable. Not here. They apply to remote nodes only (type == \"remote\"):\n    syncProtocol: String,\n    syncContext: null,\n    syncOptions: Object,\n    connected: false,\n    status: Number,\n    appliedRemoteRevision: null,\n    remoteBaseRevisions: [{\n      local: Number,\n      remote: null\n    }],\n    dbUploadState: {\n      tablesToUpload: [String],\n      currentTable: String,\n      currentKey: null,\n      localBaseRevision: Number\n    }\n  });\n  db.observable = {};\n  db.observable.SyncNode = SyncNode;\n  var wakeupObservers = initWakeupObservers(db, Observable, localStorage);\n  var overrideCreateTransaction = initOverrideCreateTransaction(db, wakeupObservers);\n  var crudMonitor = initCrudMonitor(db);\n  var overrideOpen = initOverrideOpen(db, SyncNode, crudMonitor);\n  var mySyncNode = {\n    node: null\n  };\n  var intercomm = initIntercomm(db, Observable, SyncNode, mySyncNode, localStorage);\n  var onIntercomm = intercomm.onIntercomm;\n  var consumeIntercommMessages = intercomm.consumeIntercommMessages; // Allow other addons to access the local sync node. May be needed by Dexie.Syncable.\n\n  Object.defineProperty(db, \"_localSyncNode\", {\n    get: function get() {\n      return mySyncNode.node;\n    }\n  });\n  var pollHandle = null,\n      heartbeatHandle = null;\n\n  if (Dexie.fake) {\n    // This code will never run.\n    // It's here just to enable auto-complete in visual studio - helps a lot when writing code.\n    db.version(1).stores({\n      _syncNodes: \"++id,myRevision,lastHeartBeat\",\n      _changes: \"++rev\",\n      _intercomm: \"++id,destinationNode\",\n      _uncommittedChanges: \"++id,node\"\n    });\n\n    db._syncNodes.mapToClass(SyncNode);\n\n    db._changes.mapToClass(DatabaseChange);\n\n    mySyncNode.node = new SyncNode({\n      myRevision: 0,\n      type: \"local\",\n      lastHeartBeat: Date.now(),\n      deleteTimeStamp: null\n    });\n  } //\n  // Override parsing the stores to add \"_changes\" and \"_syncNodes\" tables.\n  // It also adds UUID support for the primary key and sets tables as observable tables.\n  //\n\n\n  db.Version.prototype._parseStoresSpec = override(db.Version.prototype._parseStoresSpec, overrideParseStoresSpec); // changes event on db:\n\n  db.on.addEventType({\n    changes: 'asap',\n    cleanup: [promisableChain, nop],\n    message: 'asap'\n  }); //\n  // Override transaction creation to always include the \"_changes\" store when any observable store is involved.\n  //\n\n  db._createTransaction = override(db._createTransaction, overrideCreateTransaction); // If Observable.latestRevsion[db.name] is undefined, set it to 0 so that comparing against it always works.\n  // You might think that it will always be undefined before this call, but in case another Dexie instance in the same\n  // window with the same database name has been created already, this static property will already be set correctly.\n\n  Observable.latestRevision[db.name] = Observable.latestRevision[db.name] || 0; //\n  // Override open to setup hooks for db changes and map the _syncNodes table to class\n  //\n\n  db.open = override(db.open, overrideOpen);\n  db.close = override(db.close, function (origClose) {\n    return function () {\n      if (db.dynamicallyOpened()) return origClose.apply(this, arguments); // Don't observe dynamically opened databases.\n      // Teardown our framework.\n\n      if (wakeupObservers.timeoutHandle) {\n        clearTimeout(wakeupObservers.timeoutHandle);\n        delete wakeupObservers.timeoutHandle;\n      }\n\n      Observable.on('latestRevisionIncremented').unsubscribe(onLatestRevisionIncremented);\n      Observable.on('suicideNurseCall').unsubscribe(onSuicide);\n      Observable.on('intercomm').unsubscribe(onIntercomm);\n      Observable.on('beforeunload').unsubscribe(onBeforeUnload); // Inform other db instances in same window that we are dying:\n\n      if (mySyncNode.node && mySyncNode.node.id) {\n        Observable.on.suicideNurseCall.fire(db.name, mySyncNode.node.id); // Inform other windows as well:\n\n        if (localStorage) {\n          localStorage.setItem('Dexie.Observable/deadnode:' + mySyncNode.node.id.toString() + '/' + db.name, \"dead\"); // In IE, this will also wakeup our own window. cleanup() may trigger twice per other db instance. But that doesnt to anything.\n        }\n\n        mySyncNode.node.deleteTimeStamp = 1; // One millisecond after 1970. Makes it occur in the past but still keeps it truthy.\n\n        mySyncNode.node.lastHeartBeat = 0;\n\n        db._syncNodes.put(mySyncNode.node); // This async operation may be cancelled since the browser is closing down now.\n\n\n        mySyncNode.node = null;\n      }\n\n      if (pollHandle) clearTimeout(pollHandle);\n      pollHandle = null;\n      if (heartbeatHandle) clearTimeout(heartbeatHandle);\n      heartbeatHandle = null;\n      return origClose.apply(this, arguments);\n    };\n  }); // Override Dexie.delete() in order to delete Observable.latestRevision[db.name].\n\n  db.delete = override(db.delete, function (origDelete) {\n    return function () {\n      return origDelete.apply(this, arguments).then(function (result) {\n        // Reset Observable.latestRevision[db.name]\n        Observable.latestRevision[db.name] = 0;\n        return result;\n      });\n    };\n  }); // When db opens, make sure to start monitor any changes before other db operations will start.\n\n  db.on(\"ready\", function startObserving() {\n    if (db.dynamicallyOpened()) return db; // Don't observe dynamically opened databases.\n\n    return db.table(\"_changes\").orderBy(\"rev\").last(function (lastChange) {\n      // Since startObserving() is called before database open() method, this will be the first database operation enqueued to db.\n      // Therefore we know that the retrieved value will be This query will\n      var latestRevision = lastChange ? lastChange.rev : 0;\n      mySyncNode.node = new SyncNode({\n        myRevision: latestRevision,\n        type: \"local\",\n        lastHeartBeat: Date.now(),\n        deleteTimeStamp: null,\n        isMaster: 0\n      });\n\n      if (Observable.latestRevision[db.name] < latestRevision) {\n        // Side track . For correctness whenever setting Observable.latestRevision[db.name] we must make sure the event is fired if increased:\n        // There are other db instances in same window that hasnt yet been informed about a new revision\n        Observable.latestRevision[db.name] = latestRevision;\n        Dexie.ignoreTransaction(function () {\n          Observable.on.latestRevisionIncremented.fire(latestRevision);\n        });\n      } // Add new sync node or if this is a reopening of the database after a close() call, update it.\n\n\n      return db.transaction('rw', '_syncNodes', function () {\n        return db._syncNodes.where('isMaster').equals(1).first(function (currentMaster) {\n          if (!currentMaster) {\n            // There's no master. We must be the master\n            mySyncNode.node.isMaster = 1;\n          } else if (currentMaster.lastHeartBeat < Date.now() - NODE_TIMEOUT) {\n            // Master have been inactive for too long\n            // Take over mastership\n            mySyncNode.node.isMaster = 1;\n            currentMaster.isMaster = 0;\n            return db._syncNodes.put(currentMaster);\n          }\n        }).then(function () {\n          // Add our node to DB and start subscribing to events\n          return db._syncNodes.add(mySyncNode.node).then(function () {\n            Observable.on('latestRevisionIncremented', onLatestRevisionIncremented); // Wakeup when a new revision is available.\n\n            Observable.on('beforeunload', onBeforeUnload);\n            Observable.on('suicideNurseCall', onSuicide);\n            Observable.on('intercomm', onIntercomm); // Start polling for changes and do cleanups:\n\n            pollHandle = setTimeout(poll, LOCAL_POLL); // Start heartbeat\n\n            heartbeatHandle = setTimeout(heartbeat, HEARTBEAT_INTERVAL);\n          });\n        });\n      }).then(function () {\n        cleanup();\n      });\n    });\n  }, true); // True means the on(ready) event will survive a db reopening (db.close() / db.open()).\n\n  var handledRevision = 0;\n\n  function onLatestRevisionIncremented(dbname, latestRevision) {\n    if (dbname === db.name) {\n      if (handledRevision >= latestRevision) return; // Make sure to only run once per revision. (Workaround for IE triggering storage event on same window)\n\n      handledRevision = latestRevision;\n      Dexie.vip(function () {\n        readChanges(latestRevision).catch('DatabaseClosedError', function () {// Handle database closed error gracefully while reading changes.\n          // Don't trigger 'unhandledrejection'.\n          // Even though we intercept the close() method, it might be called when in the middle of\n          // reading changes and then that flow will cancel with DatabaseClosedError.\n        });\n      });\n    }\n  }\n\n  function readChanges(latestRevision, recursion, wasPartial) {\n    // Whenever changes are read, fire db.on(\"changes\") with the array of changes. Eventually, limit the array to 1000 entries or so (an entire database is\n    // downloaded from server AFTER we are initiated. For example, if first sync call fails, then after a while we get reconnected. However, that scenario\n    // should be handled in case database is totally empty we should fail if sync is not available)\n    if (!recursion && readChanges.ongoingOperation) {\n      // We are already reading changes. Prohibit a parallell execution of this which would lead to duplicate trigging of 'changes' event.\n      // Instead, the callback in toArray() will always check Observable.latestRevision[db.name] to see if it has changed and if so, re-launch readChanges().\n      // The caller should get the Promise instance from the ongoing operation so that the then() method will resolve when operation is finished.\n      return readChanges.ongoingOperation;\n    }\n\n    var partial = false;\n    var ourSyncNode = mySyncNode.node; // Because mySyncNode can suddenly be set to null on database close, and worse, can be set to a new value if database is reopened.\n\n    if (!ourSyncNode) {\n      return Promise$1.reject(new Dexie.DatabaseClosedError());\n    }\n\n    var LIMIT = 1000;\n\n    var promise = db._changes.where(\"rev\").above(ourSyncNode.myRevision).limit(LIMIT).toArray(function (changes) {\n      if (changes.length > 0) {\n        var lastChange = changes[changes.length - 1];\n        partial = changes.length === LIMIT;\n        db.on('changes').fire(changes, partial);\n        ourSyncNode.myRevision = lastChange.rev;\n      } else if (wasPartial) {\n        // No more changes, BUT since we have triggered on('changes') with partial = true,\n        // we HAVE TO trigger changes again with empty list and partial = false\n        db.on('changes').fire([], false);\n      }\n\n      var ourNodeStillExists = false;\n      return db._syncNodes.where(':id').equals(ourSyncNode.id).modify(function (syncNode) {\n        ourNodeStillExists = true;\n        syncNode.lastHeartBeat = Date.now(); // Update heart beat (not nescessary, but why not!)\n\n        syncNode.deleteTimeStamp = null; // Reset \"deleteTimeStamp\" flag if it was there.\n\n        syncNode.myRevision = Math.max(syncNode.myRevision, ourSyncNode.myRevision);\n      }).then(function () {\n        return ourNodeStillExists;\n      });\n    }).then(function (ourNodeStillExists) {\n      if (!ourNodeStillExists) {\n        // My node has been deleted. We must have been lazy and got removed by another node.\n        if (browserIsShuttingDown) {\n          throw new Error(\"Browser is shutting down\");\n        } else {\n          db.close();\n          console.error(\"Out of sync\"); // TODO: What to do? Reload the page?\n\n          if (global.location) global.location.reload(true);\n          throw new Error(\"Out of sync\"); // Will make current promise reject\n        }\n      } // Check if more changes have come since we started reading changes in the first place. If so, relaunch readChanges and let the ongoing promise not\n      // resolve until all changes have been read.\n\n\n      if (partial || Observable.latestRevision[db.name] > ourSyncNode.myRevision) {\n        // Either there were more than 1000 changes or additional changes where added while we were reading these changes,\n        // In either case, call readChanges() again until we're done.\n        return readChanges(Observable.latestRevision[db.name], (recursion || 0) + 1, partial);\n      }\n    }).finally(function () {\n      delete readChanges.ongoingOperation;\n    });\n\n    if (!recursion) {\n      readChanges.ongoingOperation = promise;\n    }\n\n    return promise;\n  }\n  /**\n   * The reason we need heartbeat in parallell with poll() is due to the risk of long-running\n   * transactions while syncing changes from server to client in Dexie.Syncable. That transaction will\n   * include _changes (which will block readChanges()) but not _syncNodes. So this heartbeat will go on\n   * during that changes are being applied and update our lastHeartBeat property while poll() is waiting.\n   * When cleanup() (who also is blocked by the sync) wakes up, it won't kill the master node because this\n   * heartbeat job will have updated the master node's heartbeat during the long-running sync transaction.\n   *\n   * If we did not have this heartbeat, and a server send lots of changes that took more than NODE_TIMEOUT\n   * (20 seconds), another node waking up after the sync would kill the master node and take over because\n   * it would believe it was dead.\n   */\n\n\n  function heartbeat() {\n    heartbeatHandle = null;\n    var currentInstance = mySyncNode.node && mySyncNode.node.id;\n    if (!currentInstance) return;\n    db.transaction('rw!', db._syncNodes, function () {\n      db._syncNodes.where({\n        id: currentInstance\n      }).first(function (ourSyncNode) {\n        if (!ourSyncNode) {\n          // We do not exist anymore. Call db.close() to teardown polls etc.\n          if (db.isOpen()) db.close();\n          return;\n        }\n\n        ourSyncNode.lastHeartBeat = Date.now();\n        ourSyncNode.deleteTimeStamp = null; // Reset \"deleteTimeStamp\" flag if it was there.\n\n        return db._syncNodes.put(ourSyncNode);\n      });\n    }).catch('DatabaseClosedError', function () {// Ignore silently\n    }).finally(function () {\n      if (mySyncNode.node && mySyncNode.node.id === currentInstance && db.isOpen()) {\n        heartbeatHandle = setTimeout(heartbeat, HEARTBEAT_INTERVAL);\n      }\n    });\n  }\n\n  function poll() {\n    pollHandle = null;\n    var currentInstance = mySyncNode.node && mySyncNode.node.id;\n    if (!currentInstance) return;\n    Dexie.vip(function () {\n      readChanges(Observable.latestRevision[db.name]).then(cleanup).then(consumeIntercommMessages).catch('DatabaseClosedError', function () {// Handle database closed error gracefully while reading changes.\n        // Don't trigger 'unhandledrejection'.\n        // Even though we intercept the close() method, it might be called when in the middle of\n        // reading changes and then that flow will cancel with DatabaseClosedError.\n      }).finally(function () {\n        // Poll again in given interval:\n        if (mySyncNode.node && mySyncNode.node.id === currentInstance && db.isOpen()) {\n          pollHandle = setTimeout(poll, LOCAL_POLL);\n        }\n      });\n    });\n  }\n\n  function cleanup() {\n    var ourSyncNode = mySyncNode.node;\n    if (!ourSyncNode) return Promise$1.reject(new Dexie.DatabaseClosedError());\n    return db.transaction('rw', '_syncNodes', '_changes', '_intercomm', function () {\n      // Cleanup dead local nodes that has no heartbeat for over a minute\n      // Dont do the following:\n      //nodes.where(\"lastHeartBeat\").below(Date.now() - NODE_TIMEOUT).and(function (node) { return node.type == \"local\"; }).delete();\n      // Because client may have been in hybernate mode and recently woken up. That would lead to deletion of all nodes.\n      // Instead, we should mark any old nodes for deletion in a minute or so. If they still dont wakeup after that minute we could consider them dead.\n      var weBecameMaster = false;\n\n      db._syncNodes.where(\"lastHeartBeat\").below(Date.now() - NODE_TIMEOUT).filter(function (node) {\n        return node.type === 'local';\n      }).modify(function (node) {\n        if (node.deleteTimeStamp && node.deleteTimeStamp < Date.now()) {\n          // Delete the node.\n          delete this.value; // Cleanup localStorage \"deadnode:\" entry for this node (localStorage API was used to wakeup other windows (onstorage event) - an event type missing in indexedDB.)\n\n          if (localStorage) {\n            localStorage.removeItem('Dexie.Observable/deadnode:' + node.id + '/' + db.name);\n          } // Check if we are deleting a master node\n\n\n          if (node.isMaster) {\n            // The node we are deleting is master. We must take over that role.\n            // OK to call nodes.update(). No need to call Dexie.vip() because nodes is opened in existing transaction!\n            db._syncNodes.update(ourSyncNode, {\n              isMaster: 1\n            });\n\n            weBecameMaster = true;\n          } // Cleanup intercomm messages destinated to the node being deleted.\n          // Those that waits for reply should be redirected to us.\n\n\n          db._intercomm.where({\n            destinationNode: node.id\n          }).modify(function (msg) {\n            if (msg.wantReply) msg.destinationNode = ourSyncNode.id;else // Delete the message from DB and if someone is waiting for reply, let ourselved answer the request.\n              delete this.value;\n          });\n        } else if (!node.deleteTimeStamp) {\n          // Mark the node for deletion\n          node.deleteTimeStamp = Date.now() + HIBERNATE_GRACE_PERIOD;\n        }\n      }).then(function () {\n        // Cleanup old revisions that no node is interested of.\n        Observable.deleteOldChanges(db);\n        return db.on(\"cleanup\").fire(weBecameMaster);\n      });\n    });\n  }\n\n  function onBeforeUnload() {\n    // Mark our own sync node for deletion.\n    if (!mySyncNode.node) return;\n    browserIsShuttingDown = true;\n    mySyncNode.node.deleteTimeStamp = 1; // One millisecond after 1970. Makes it occur in the past but still keeps it truthy.\n\n    mySyncNode.node.lastHeartBeat = 0;\n\n    db._syncNodes.put(mySyncNode.node); // This async operation may be cancelled since the browser is closing down now.\n\n\n    Observable.wereTheOneDying = true; // If other nodes in same window wakes up by this call, make sure they dont start taking over mastership and stuff...\n    // Inform other windows that we're gone, so that they may take over our role if needed. Setting localStorage item below will trigger Observable.onStorage, which will trigger onSuicie() below:\n\n    if (localStorage) {\n      localStorage.setItem('Dexie.Observable/deadnode:' + mySyncNode.node.id.toString() + '/' + db.name, \"dead\"); // In IE, this will also wakeup our own window. However, that is doublechecked in nursecall subscriber below.\n    }\n  }\n\n  function onSuicide(dbname, nodeID) {\n    if (dbname === db.name && !Observable.wereTheOneDying) {\n      // Make sure it's dead indeed. Second bullet. Why? Because it has marked itself for deletion in the onbeforeunload event, which is fired just before window dies.\n      // It's own call to put() may have been cancelled.\n      // Note also that in IE, this event may be called twice, but that doesnt harm!\n      Dexie.vip(function () {\n        db._syncNodes.update(nodeID, {\n          deleteTimeStamp: 1,\n          lastHeartBeat: 0\n        }).then(cleanup);\n      });\n    }\n  }\n} //\n// Static properties and methods\n// \n\n\nObservable.latestRevision = {}; // Latest revision PER DATABASE. Example: Observable.latestRevision.FriendsDB = 37;\n\nObservable.on = Dexie.Events(null, \"latestRevisionIncremented\", \"suicideNurseCall\", \"intercomm\", \"beforeunload\"); // fire(dbname, value);\n\nObservable.createUUID = createUUID;\nObservable.deleteOldChanges = deleteOldChanges;\nObservable._onStorage = initOnStorage(Observable);\n\nObservable._onBeforeUnload = function () {\n  Observable.on.beforeunload.fire();\n};\n\ntry {\n  Observable.localStorageImpl = global.localStorage;\n} catch (ex) {} //\n// Map window events to static events in Dexie.Observable:\n//\n\n\nif (global.addEventListener) {\n  global.addEventListener(\"storage\", Observable._onStorage);\n  global.addEventListener(\"beforeunload\", Observable._onBeforeUnload);\n} // Register addon:\n\n\nDexie.Observable = Observable;\nDexie.addons.push(Observable);\nexport default Observable;","map":null,"metadata":{},"sourceType":"module"}