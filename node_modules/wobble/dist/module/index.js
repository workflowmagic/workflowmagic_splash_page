"use strict";
/**
 *  @license
 *  Copyright 2017 Adam Miskiewicz
 *
 *  Use of this source code is governed by a MIT-style license that can be found
 *  in the LICENSE file or at https://opensource.org/licenses/MIT.
 */
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
/**
 * Implements a spring physics simulation based on the equations behind
 * damped harmonic oscillators (https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator).
 */
var Spring = /** @class */ (function () {
    function Spring(config) {
        if (config === void 0) { config = {}; }
        this._listeners = [];
        this._currentAnimationStep = 0; // current requestAnimationFrame
        this._currentTime = 0; // Current timestamp of animation in ms (real time)
        this._springTime = 0; // Current time along the spring curve in ms (zero-based)
        this._currentValue = 0; // the current value of the spring
        this._currentVelocity = 0; // the current velocity of the spring
        this._isAnimating = false;
        this._oscillationVelocityPairs = [];
        this._config = {
            fromValue: utils_1.withDefault(config.fromValue, 0),
            toValue: utils_1.withDefault(config.toValue, 1),
            stiffness: utils_1.withDefault(config.stiffness, 100),
            damping: utils_1.withDefault(config.damping, 10),
            mass: utils_1.withDefault(config.mass, 1),
            initialVelocity: utils_1.withDefault(config.initialVelocity, 0),
            overshootClamping: utils_1.withDefault(config.overshootClamping, false),
            allowsOverdamping: utils_1.withDefault(config.allowsOverdamping, false),
            restVelocityThreshold: utils_1.withDefault(config.restVelocityThreshold, 0.001),
            restDisplacementThreshold: utils_1.withDefault(config.restDisplacementThreshold, 0.001)
        };
        this._currentValue = this._config.fromValue;
        this._currentVelocity = this._config.initialVelocity;
    }
    /**
     * If `fromValue` differs from `toValue`, or `initialVelocity` is non-zero,
     * start the simulation and call the `onStart` listeners.
     */
    Spring.prototype.start = function () {
        var _this = this;
        var _a = this._config, fromValue = _a.fromValue, toValue = _a.toValue, initialVelocity = _a.initialVelocity;
        if (fromValue !== toValue || initialVelocity !== 0) {
            this._reset();
            this._isAnimating = true;
            if (!this._currentAnimationStep) {
                this._notifyListeners("onStart");
                this._currentAnimationStep = requestAnimationFrame(function (t) {
                    _this._step(Date.now());
                });
            }
        }
        return this;
    };
    /**
     * If a simulation is in progress, stop it and call the `onStop` listeners.
     */
    Spring.prototype.stop = function () {
        if (!this._isAnimating) {
            return this;
        }
        this._isAnimating = false;
        this._notifyListeners("onStop");
        if (this._currentAnimationStep) {
            cancelAnimationFrame(this._currentAnimationStep);
            this._currentAnimationStep = 0;
        }
        return this;
    };
    Object.defineProperty(Spring.prototype, "currentValue", {
        /**
         * The spring's current position.
         */
        get: function () {
            return this._currentValue;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Spring.prototype, "currentVelocity", {
        /**
         * The spring's current velocity in units / ms.
         */
        get: function () {
            return this._currentVelocity; // give velocity in units/ms;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Spring.prototype, "isAtRest", {
        /**
         * If the spring has reached its `toValue`, or if its velocity is below the
         * `restVelocityThreshold`, it is considered at rest. If `stop()` is called
         * during a simulation, both `isAnimating` and `isAtRest` will be false.
         */
        get: function () {
            return this._isSpringAtRest();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Spring.prototype, "isAnimating", {
        /**
         * Whether or not the spring is currently emitting values.
         *
         * Note: this is distinct from whether or not it is at rest.
         * See also `isAtRest`.
         */
        get: function () {
            return this._isAnimating;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the spring config with the given values.  Values not explicitly
     * supplied will be reused from the existing config.
     */
    Spring.prototype.updateConfig = function (updatedConfig) {
        // When we update the spring config, we reset the simulation to ensure the
        // spring always moves the full distance between `fromValue` and `toValue`.
        // To ensure that the simulation behaves correctly if those values aren't
        // being changed in `updatedConfig`, we run the simulation with `_step()`
        // and default `fromValue` and `initialVelocity` to their current values.
        this._advanceSpringToTime(Date.now());
        var baseConfig = {
            fromValue: this._currentValue,
            initialVelocity: this._currentVelocity
        };
        this._config = __assign({}, this._config, baseConfig, updatedConfig);
        this._reset();
        return this;
    };
    /**
     * The provided callback will be invoked when the simulation begins.
     */
    Spring.prototype.onStart = function (listener) {
        this._listeners.push({ onStart: listener });
        return this;
    };
    /**
     * The provided callback will be invoked on each frame while the simulation is
     * running.
     */
    Spring.prototype.onUpdate = function (listener) {
        this._listeners.push({ onUpdate: listener });
        return this;
    };
    /**
     * The provided callback will be invoked when the simulation ends.
     */
    Spring.prototype.onStop = function (listener) {
        this._listeners.push({ onStop: listener });
        return this;
    };
    /**
     * Remove a single listener from this spring.
     */
    Spring.prototype.removeListener = function (listenerFn) {
        this._listeners = this._listeners.reduce(function (result, listener) {
            var foundListenerFn = Object.values(listener).indexOf(listenerFn) !== -1;
            if (!foundListenerFn) {
                result.push(listener);
            }
            return result;
        }, []);
        return this;
    };
    /**
     * Removes all listeners from this spring.
     */
    Spring.prototype.removeAllListeners = function () {
        this._listeners = [];
        return this;
    };
    Spring.prototype._reset = function () {
        this._currentTime = Date.now();
        this._springTime = 0.0;
        this._currentValue = this._config.fromValue;
        this._currentVelocity = this._config.initialVelocity;
    };
    Spring.prototype._notifyListeners = function (eventName) {
        var _this = this;
        this._listeners.forEach(function (listener) {
            var maybeListenerFn = listener[eventName];
            if (typeof maybeListenerFn === "function") {
                maybeListenerFn(_this);
            }
        });
    };
    /**
     * `_step` is the main loop.  While the animation is running, it updates the
     * current state once per frame, and schedules the next frame if the spring is
     * not yet at rest.
     */
    Spring.prototype._step = function (timestamp) {
        var _this = this;
        this._advanceSpringToTime(timestamp, true);
        // check `_isAnimating`, in case `stop()` got called during
        // `_advanceSpringToTime()`
        if (this._isAnimating) {
            this._currentAnimationStep = requestAnimationFrame(function (t) {
                return _this._step(Date.now());
            });
        }
    };
    Spring.prototype._advanceSpringToTime = function (timestamp, shouldNotifyListeners) {
        if (shouldNotifyListeners === void 0) { shouldNotifyListeners = false; }
        // `_advanceSpringToTime` updates `_currentTime` and triggers the listeners.
        // Because of these side effects, it's only safe to call when an animation
        // is already in-progress.
        if (!this._isAnimating) {
            return;
        }
        var deltaTime = timestamp - this._currentTime;
        // If for some reason we lost a lot of frames (e.g. process large payload or
        // stopped in the debugger), we only advance by 4 frames worth of
        // computation and will continue on the next frame. It's better to have it
        // running at slower speed than jumping to the end.
        if (deltaTime > Spring.MAX_DELTA_TIME_MS) {
            deltaTime = Spring.MAX_DELTA_TIME_MS;
        }
        this._springTime += deltaTime;
        var c = this._config.damping;
        var m = this._config.mass;
        var k = this._config.stiffness;
        var fromValue = this._config.fromValue;
        var toValue = this._config.toValue;
        var v0 = -this._config.initialVelocity;
        utils_1.invariant(m > 0, "Mass value must be greater than 0");
        utils_1.invariant(k > 0, "Stiffness value must be greater than 0");
        utils_1.invariant(c > 0, "Damping value must be greater than 0");
        var zeta = c / (2 * Math.sqrt(k * m)); // damping ratio (dimensionless)
        var omega0 = Math.sqrt(k / m) / 1000; // undamped angular frequency of the oscillator (rad/ms)
        var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay
        var omega2 = omega0 * Math.sqrt(zeta * zeta - 1.0); // frequency of damped oscillation
        var x0 = toValue - fromValue; // initial displacement of the spring at t = 0
        if (zeta > 1 && !this._config.allowsOverdamping) {
            zeta = 1;
        }
        var oscillation = 0.0;
        var velocity = 0.0;
        var t = this._springTime;
        if (zeta < 1) {
            // Under damped
            var envelope = Math.exp(-zeta * omega0 * t);
            oscillation =
                toValue -
                    envelope *
                        ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) +
                            x0 * Math.cos(omega1 * t));
            // This looks crazy -- it's actually just the derivative of the
            // oscillation function
            velocity =
                zeta *
                    omega0 *
                    envelope *
                    (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 +
                        x0 * Math.cos(omega1 * t)) -
                    envelope *
                        (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) -
                            omega1 * x0 * Math.sin(omega1 * t));
        }
        else if (zeta === 1) {
            // Critically damped
            var envelope = Math.exp(-omega0 * t);
            oscillation = toValue - envelope * (x0 + (v0 + omega0 * x0) * t);
            velocity =
                envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
        }
        else {
            // Overdamped
            var envelope = Math.exp(-zeta * omega0 * t);
            oscillation =
                toValue -
                    envelope *
                        ((v0 + zeta * omega0 * x0) * Math.sinh(omega2 * t) +
                            omega2 * x0 * Math.cosh(omega2 * t)) /
                        omega2;
            velocity =
                envelope *
                    zeta *
                    omega0 *
                    (Math.sinh(omega2 * t) * (v0 + zeta * omega0 * x0) +
                        x0 * omega2 * Math.cosh(omega2 * t)) /
                    omega2 -
                    envelope *
                        (omega2 * Math.cosh(omega2 * t) * (v0 + zeta * omega0 * x0) +
                            omega2 * omega2 * x0 * Math.sinh(omega2 * t)) /
                        omega2;
        }
        this._currentTime = timestamp;
        this._currentValue = oscillation;
        this._currentVelocity = velocity;
        if (!shouldNotifyListeners) {
            return;
        }
        this._notifyListeners("onUpdate");
        if (!this._isAnimating) {
            // a listener might have stopped us in _onUpdate
            return;
        }
        // If the Spring is overshooting (when overshoot clamping is on), or if the
        // spring is at rest (based on the thresholds set in the config), stop the
        // animation.
        if (this._isSpringOvershooting() || this._isSpringAtRest()) {
            if (k !== 0) {
                // Ensure that we end up with a round value
                this._currentValue = toValue;
                this._currentVelocity = 0;
                this._notifyListeners("onUpdate");
            }
            this.stop();
            return;
        }
    };
    Spring.prototype._isSpringOvershooting = function () {
        var _a = this._config, stiffness = _a.stiffness, fromValue = _a.fromValue, toValue = _a.toValue, overshootClamping = _a.overshootClamping;
        var isOvershooting = false;
        if (overshootClamping && stiffness !== 0) {
            if (fromValue < toValue) {
                isOvershooting = this._currentValue > toValue;
            }
            else {
                isOvershooting = this._currentValue < toValue;
            }
        }
        return isOvershooting;
    };
    Spring.prototype._isSpringAtRest = function () {
        var _a = this._config, stiffness = _a.stiffness, toValue = _a.toValue, restDisplacementThreshold = _a.restDisplacementThreshold, restVelocityThreshold = _a.restVelocityThreshold;
        var isNoVelocity = Math.abs(this._currentVelocity) <= restVelocityThreshold;
        var isNoDisplacement = stiffness !== 0 &&
            Math.abs(toValue - this._currentValue) <= restDisplacementThreshold;
        return isNoDisplacement && isNoVelocity;
    };
    Spring.MAX_DELTA_TIME_MS = 1 / 60 * 1000 * 4; // advance 4 frames at max
    return Spring;
}());
exports.Spring = Spring;
//# sourceMappingURL=index.js.map